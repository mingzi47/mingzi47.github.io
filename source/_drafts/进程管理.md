---
title: "进程管理"
date: 2023-07-17T23:45:14+08:00
categories:
  - Linux
tags:
  - 进程管理
  - 操作系统
index_img: /images/Linux/进程管理/0.png
---

# 进程管理

> 进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。

## 进程

进程也可以说是正在运行的程序的实例.

保存在文件上的代码经过编译后会生成二进制可执行文件, 运行这个可执行文件后, 它会被装载到内存中, 接着 CPU 会从中执行每一条指令.

在运行一个可执行文件时, CPU 并不会一直被这个可执行文件占有, 当着个可执行文件有读取磁盘的指令时, CPU 执行了这一条指令后, 并不是使用 CPU 去磁盘中读取数据, 而是告诉其他设备去读取磁盘, 读取磁盘的过程是相当缓慢的对于 CPU 而言, CPU 并不会一直等着结果, 而是会去执行其他进程, 当磁盘读取结束时, CPU 会收到**中断**, CPU 会继续接着上次的执行进度接着执行这个进程.

![](/images/Linux/进程管理/1.webp)

对于支持多进程的系统, CPU 会从一个进程切换到另一个进程, 期间每个进程都会执行几十到几百毫秒, 这样就是并发.

![并发与并行](/images/Linux/进程管理/2.webp)

### 进程的状态

程序在被执行后, 会从运行的状态切换到暂停的状态, 又回从暂停的状态切换到运行的状态.

![进程的状态](/images/Linux/进程管理/3.webp)

- **运行状态** : 进程占用 CPU
- **就绪状态** : 当进程得到 CPU 后就能立刻执行
- **阻塞状态** : 进程因为等待某件事的发生(例如输入、输出事件的完成), 此时即使得到 CPU 也无法继续执行
- **创建状态** : 进程正在被创建的状态
- **结束状态** : 进程正在消失的状态
- **就绪挂起状态** : 进程在外存(磁盘), 只要进入内存, 就立刻执行
- **阻塞挂起状态** : 进程在外存(磁盘)等待某件事情发生

大量的阻塞进程会占用大量的内存空间, 因此, 使用虚拟内存管理的操作系统会把阻塞进程放到磁盘中去, 等再次需要运行时从磁盘中取出.

使用 sleep 和 `Ctrl-z` 也会使进程进入挂起的状态

### 进程的控制结构

在操作系统中使用 **进程控制块(process control block, PCB)** 数据结构来描述进程

PCB 是进程存在的唯一标识, 当 PCB 消失时, 进程也会消失.

PCB 包含以下信息:

- **进程描述信息**
  - 进程标识符 : 标识各个进程, 每个进程都有一个唯一标识符
  - 用户标识符 : 进程归属的用户
- **进程控制和管理信息**
  - 进程当前状态 : 如 new、ready、running、waiting 或 blocked 等
  - 进程优先级 : 进程抢占 CPU 时的优先级
- **资源分配清单**
  - 有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。
- **CPU 相关信息**
  - CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。

### 进程的控制

**创建进程**

操作系统允许进程创建进程, 子进程拥有父进程的所有资源

创建过程如下:

- 创建一个空白的 PCB, 并向 PCB 中填写一些控制和管理进程的信息, 如进程表示符等
- 为该进程分配运行时所需要的资源, 如内存资源
- 将 PCB 插入到就绪队列等待运行

**终止进程**

进程有三种终止方式: 正常终止, 异常终止和外界干预(信号, kill)

子进程终止时,父进程会帮其释放内核中的资源, 父进程终止时,其所有子进程都会由 1 号进程接管,并为它们释放内核中的资源.

终止进程的过程:

- 查找需要终止进程的 PCB
- 如果处于执行状态,立即终止该进程,将 CPU 资源分配给其他进程
- 如果还有子进程,这交给 1 号进程管理
- 将该进程的资源归还给操作系统
- 将其从 PCB 队列中删除

**阻塞进程**

进程由运行状态切换到阻塞状态是因为需要等待某件事发生, 进程不能自己唤醒自己,需要其他进程来唤醒它

阻塞进程的过程:

- 找到将要被阻塞的进程 PCB
- 如果进程正在运行,则保护其现场(记录 CPU 寄存器信息等), 将其状态设置为阻塞状态,停止运行
- 将该 PCB 插入到阻塞队列中

**唤醒进程**

唤醒进程的过程:

- 在该事件的阻塞队列中找到需要唤醒的进程 PCB
- 将其从阻塞队列中移除, 设置 PCB 状态为就绪状态
- 把该 PCB 插入到就绪队列中, 等待调度程序调度

### 进程的上下文切换

阻塞进程时,要停下当前进程,切换为其他进程执行,这就是**进程的上下问切换**

对于新切换到的进程, CPU 需要知道该进程上次运行时最后的 CPU 状态(CPU 寄存器和程序计数器), 虚拟内存等, 知道这些 CPU 就可以接着上次运行的进度接着运行.

在阻塞进程时, 也要保存 CPU 状态, 虚拟内存、栈、全局变量、内核堆栈等资源, 以便下次运行时可以接着当前进度继续运行.

![进程的上下文切换](/images/Linux/进程管理/4.webp)

进程的上下文切换开小必须越小越好,时间应该更多的花费在执行程序上,而不是切换程序.

## 进程调度算法

### 进程调度

操作系统把正在运行的进程切换到其他状态时, 就要选择下一个要运行的进程, 这就是进程调度.

**调度时机**

发生调度的时机 :

- **就绪态**到**运行态**
- **运行态**到**阻塞态**
- **运行态**到**结束态**

前一个状态向后一个状态转变时都要去选择下一个要运行的进程

根据如何处理时钟, 把调度算法分为两类:

- **非抢占式调度算法** 会挑选一个进程执行,直到发生阻塞或者进程执行结束才会去选择下一个要执行的进程,这种调度算法不会理会**时钟中断**事件
- **抢占式调度算法** 会挑选一个进程执行一段时间,时间结束时将该进程挂起,选择下一个要执行的进程,在时间结束时会发生**时钟中断**, 以便把 CPU 控制权交给调度程序,也被称为时间片机制

**调度原则**

- 当进程发生 IO 事件时, CPU 会空闲下来, 这时**为了提高 CPU 的利用率**, 调度程序需要选择一个进程来执行
- **为了提高 CPU 的吞吐率**, 不会一直让需要执行长时间任务的进程一直占用着 CPU
- 调度程序应该避免进程的**等待时间很长执行时间很短**的情况发生
- **就绪队列中进程的等待时间**也是调度程序所需要考虑的原则。
- 对于交互式比较强的应用，**响应时间**也是调度程序需要考虑的原则。

### 先来先服务

先来先服务算法 (First Come First Served, FCFS) 是**非抢占式的调度算法**

![先来先服务](/images/Linux/进程管理/5.webp)

会根据进程到来的顺序进行排队, 执行完一个进程才会继续执行下一个.

FCFS 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I/O 繁忙型作业的系统。

### 最短作业优先

同样是非抢占式的调度算法, 最短作业优先算法依据进程需要运行的时间长短来排序, 需要时间短的会先被执行.

![最短作业优先](/images/Linux/进程管理/6.webp)

这种算法对长作业是不利的, 可能会不断到来很多短作业, 使长作业永远没办法执行

### 高响应比优先

高响应比优先算法通过**响应比的大小**来对要运行的作业进行排序, 相应比大的要先运行.

$$
相应比 = \frac{等待时间 + 要求服务时间}{要求服务时间}
$$

- 当等待时间相等时, 要求服务时间越短, 就会被先执行
- 当等待的时间足够长时, 要求服务时间特别长的作业也会被执行

平衡了短作业与长作业

### 时间片轮转

时间片轮转算法是抢占式的调度算法.

![时间片轮转](/images/Linux/进程管理/7.webp)

- 作业在只会运行一个时间片的时间, 当时间片结束时, 作业如果没有运行结束, 就要到队伍后面等待, CPU 开始执行下一个作业.
- 如果作业在时间片结束前就执行结束了, 立即开始执行下一个作业.

时间片轮转算法的关键是如何设置时间片

- 如果时间片设置的过短, 就会产生大量的上下文切换, 影响 CPU 效率
- 如果时间片设置的过长, 就会使短作业的响应时间增加, 一般将时间片设为 `20ms ~ 50ms`

### 最高优先级

最高优先级算法是跟据优先级大小来排序, 优先级大的先执行.

优先级分为**静态优先级**与**动态优先级** :

- 静态优先级, 在进程创建的时候就确定了, 在运行过程中不会改变
- 动态优先级, 根据进程的动态变化调整, 会随着时间的推移增加等待进程的优先级

该算法也有两种处理优先级的方式, 抢占式和非抢占式 :

- 抢占式: 当就绪队列出现更高优先级的进程时, 挂起当前进程, 执行最高优先级的进程
- 非抢占式: 当就绪队列出现更高优先级的进程时, 会执行完当前进程再去执行最高优先级的进程

也会存在优先级低的进程永远无法被执行

### 多级反馈队列

![多级反馈队列](/images/Linux/进程管理/8.webp)

- 有多个队列, 每个队列表示一个优先级, 优先级越高的队列, 队列中的作业分配到的时间片越短
- 当更高优先级的队列加入一个新作业时, 会挂起当前作业去执行更高优先级队列里的作业

执行过程 :

- 先执行优先级高的队列中的作业, 在规定的时间片内没有执行完, 将这个作业放到下一个优先级队列的队尾
- 当优先级高的队列为空时, 开始执行下一优先级的队列中的作业

对于短作业而言, 可以在第一个队列中就被执行结束, 对于长作业虽然等待的时间变长了, 但是会获得更长时间的时间片

## 进程间的通信

### 管道

管道在 Linux 命令中的应用比较常见

```shell
ps aux | grep root
```

这段命令中的 `|` 表示的就是管道, `ps` 命令将输出写到管道中, `grep` 命令从管道中读取数据

这里的管道指的是 **匿名管道**, 管道分为**命名管道**与**匿名管道**两种

管道是先进先出的, 只有一端可以读数据, 一端可以写数据

![管道](/images/Linux/进程管理/9.webp)

**匿名管道**

匿名管道是存在于内存中的.

匿名管道可以通过以下系统调用来生成

```c
int pipe(int pipefd[2])
```

`pipefd[2]` 是创建的匿名管道的文件描述符, `pipefd[0]` 是管道的读端, `pipefd[1]` 是管道的写端

匿名管道通常用于父进程与子进程之间的通信, 使用 `fork()` 创建出来的子进程会复制文件描述符 `pipefd[2]`, 一个管道只能用于单向通信,如果想要双向通行,就要使用两个管道

匿名管道无法在两个或多个没有关系的进程中通信

**命名管道**

可以使用 Linux 命令来创建一个命名管道, 命名管道是类型为管道的设备文件, 可以通过文件读写的方式在多个进程中通信

```shell
mkfifo pipe_name
```

![命名管道](/images/Linux/进程管理/10.png)

### 消息队列

消息队列时保存在内核中的消息链表, 向消息队列中发送一条消息, 就是向内核中的消息链表中增加一个节点, 从消息队列中取出一条消息, 内核中的消息链表会将这个节点删除.

消息队列中的消息是有类型的, 也可以取出指定类型的消息, 消息队列中的每条消息都有长度限制, 消息队列所包含的消息体的总长度也是有上限的, 因此不适合大文件传输.

消息队列也需要用户态到内核态的数据拷贝, 开销也比较大

### 共享内存

操作系统使用虚拟内存来管理内存, 在两个不同的进程中, 即使虚拟内存一致其所指向的物理内存也不一致, 对于数据的增删查改互不影响.

共享内存的机制是, 就是拿出一块虚拟内存映射到相同的物理内存中, 这样写到共享内存中的数据就能被其他进程看到了.

如果一个进程正在读取共享内存中的数据, 另一个进程把正在读取的数据覆盖了,会产生了冲突.

### 信号量

信号量可以实现在任意时刻只有一个进程访问共享内存,防止了多个进程竞争共享资源而导致的数据错乱

信号量是一个整形技术器, 主要用于进程间的互斥与同步.

信号量表示共享资源的数量, 控制信号量有两个**原子**操作:

- P 操作, 这个操作会把信号量 `-1`, 相减后信号量 `< 0`, 则表明资源全部被占用, 进程需要阻塞等待; 相减后信号量 `>= 0`, 还有资源可以使用, 进程可以正常执行
- V 操作, 这个操作会把信号量 `+1`, 想加后信号量 `<= 0`, 则表明有进程被阻塞, 需要将其唤醒; 相加后信号量 `> 0`, 则表明当前没有阻塞中的进程

如果两个进程需要访问共享内存, 把信号量设为 `1`

![信号量进程互斥](/images/Linux/进程管理/11.webp)

具体过程:

- 进程 A 访问共享内存前执行了 P 操作, 因为还没有别的进程在共享内存中, 所以信号量还是初始值 `1`, 在进行了 P 操作后, 信号量变为了 `0`, 进程 A 进入共享内存继续执行, 此时进程 B 需要访问共享内存, 先执行 P 操作, P 操作结束后, 信号量为 `-1`, 因此进程 B 需要被阻塞
- 进程 A 访问结束共享内存后, 需要执行 V 操作, 操作过后信号量为 `0`, 表示有进程被阻塞, 唤醒阻塞进程 B, B 进程进入共享内存, 进程 B 结束, 执行 V 操作, 信号量为 `1`, 没有进程阻塞.

信号量初始为 `1`, 表示**互斥信号量**, 保证在任意时刻都只有一个进程访问共享资源

如果进程 A 只负责写数据, 进程 B 只负责读数据, 将信号量初始为 `0`

![信号量进程同步](/images/Linux/进程管理/12.webp)

具体过程:

- 如果进程 B 需要从共享内存中读取数据, 行执行 P 操作, 信号量变为 `-1`, 共享内存中没有数据, 进程 B 需要阻塞, 等待数据写入
- 进程 A 需要向共享内存中写入数据, 写完数据后, 执行 V 操作, 信号量变为 `0`, 唤醒阻塞中的进程 B
- 进程 B 从共享内存中读取数据

信号量初始为 `0`, 表示**同步信号量**

### 信号

在 Linux 中使用 `kill` 命令就是向一个进程发送一个信号

```shell
# 信号类型
kill -l
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX
```

运行在 `shell` 终端中的进程, 通过使用快捷键也可以接受到一个信号,

- `Ctrl + c` : 发送 `2) SIGINT` 信号, 表示终止该进程
- `Ctrl + z` : 发送 `20) SIGTSTP` 信号, 表示停止该进程, 代还未结束

信号是进程间通信机制中唯一的异**步通信机制**，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。

- 执行默认操作。Linux 对每种信号都规定了默认操作，例如，上面列表中的 SIGTERM 信号，就是终止进程的意思。

- 捕捉信号。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。

- 忽略信号。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 SIGKILL 和 SEGSTOP，它们用于在任何时候中断或结束某一进程。

### Socket

与不同主机之间的进程通信需要用到 Socket

Socket 有三种通信方式:

- TCP 字节流通信, 保证数据的可靠, 有序, 需要指定 ip 和 端口

![TCP](/images/Linux/进程管理/13.webp)

- UDP 数据报通信, 快速, 不太可靠, 需要指定 ip 和 端口

![UDP](/images/Linux/进程管理/14.webp)

- 本地进程间通信, 不需要绑定端口, 当需要指定本地文件

## 线程
