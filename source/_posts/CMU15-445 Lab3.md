---
title: "CMU15-445 Lab3 : 支持查询"
date: 2023-04-01T23:45:14+08:00
tags:
- "CMU15-445"
- "Lab"
- "火山模型"
categories:
- "数据库"
---

## Task1 - System Catalog

维护一个内部的目录来跟踪数据库内的元数据。

### Schema (class)

表的结构信息，不包含表的实际数据。

```sql
CREATE TABLE `t_user` (
  `id` int(11) NOT NULL,
  `name` VARCHAR(20) DEFAULT NULL,
  `phone` VARCHAR(20) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB DEFAULT CHARACTER SET = ascii ROW_FORMAT = COMPACT;
```

这些信息就由 `Schema` 来储存，真实数据数据会通过 `Tuple`  来储存。

`TableHeap` 与 `Schema` 结合才是完整的表。

#### Column (class)

表示列的信息。

```cpp
// 例如： column_name_ = 'id' column_type_ = INTEGER ...
std::string column_name_;      // column 名字
TypeId column_type_;           // column 类型  INVALID, BOOLEAN, TINYINT, SMALLINT, INTEGER, BIGINT, DECIMAL, VARCHAR, TIMESTAMP 
uint32_t variable_length_{0};  // 变量长度
uint32_t column_offset_{0};    // 这一列在 `Tuple` 中的偏移量
```

### TableHeap (class)

表示磁盘上的物理表。

由多个 `TablePage` 组成，插入时从第一张 `TablePage` 开始，不能插入就尝试下一张，或者新建一张（没有下一张时），只到由空余的位置插入 `Tuple`。

更新，删除，查找通过  `Rid::GetPageId()` 可以轻松在 `BufferPoolManger` 中找到对应的 `TablePage`，并且通过 `Rid::GetSlotNum()` 在  `TablePage` 中找到对应的 `Tuple`。 

#### TablePage (class)

继承 `Page` 

![format](/images/数据库/CMU15-445/Lab3/format.png)

Header 的大小是 24 ，使用偏移量来获得 `Page` 中的每个值。

**插入 Tuple**

使用 `memcpy` 将 `Tuple::Data` 拷贝一份到`TablePage::Data` 对应的位置上。

同时会修改参数 `Rid` 做为这条 `Tuple` 的标志符，接下来更新、删除、查找这条 `Tuple` 都要依靠 `Rid`。

**更新 Tuple**

使用`memmove` 来将原来的 `TablePage::Data` 中要被更新的 `Tuple::Data` 移动到`TablePage::Data`后面。

重新设置`TablePage::Data` 中的 `Tuple::Data`的偏移量。

**删除 Tuple**

##### MarkDelete

只是标记为被删除，实际 `TupleCount` 和 `free_space_pointer` 都没有被改变，之后可以通过 `TablePage::RollbackDelete(const RID &rid,...)` 来恢复。

##### ApplyDelete

使用 `memmove` 将内容移除，不可恢复，删除后同样需要设置 `TablePage::Data` 中的 `Tuple::Data`的偏移量。

##### Tuple (class)

```cpp
bool allocated_;  // 是否被分配了内存
uint32_t size_;   // 被分配内存的大小
char *data_;      // 被分配的内存（数据）
```

![format](/images/数据库/CMU15-445/Lab3/tuple_format.png)

##### Rid (class)

通过 `Rid` 就能快速找到 `TablePage` 中的 `Tuple` 。

```cpp
page_id_t page_id_{INVALID_PAGE_ID};  // 这个 `Tuple` 在哪页上
uint32_t slot_num_{0};                // `TablePage` 中的偏移量
```

#### TableIterator (class)

为 sequential scan TableHeap 提供的迭代器。

`*TableIterator` 会返回一个 `Tuple` 

`TableIterator` 只会向前迭代，每次都是迭代一张表（而不是一张 `Page`，一张表可能有多个 `Page` 组成 ）。

### TableMetadata (class)

```cpp
Schema schema_;
std::string name_;
std::unique_ptr<TableHeap> table_;
table_oid_t oid_;
```

将 `TableHeap` 与 `Schema` 封装起来组成完整的表，同时加入表名称 `name` 和表的标示号 `oid_` 来帮助 `Catalog` 管理多个表。

### IndexInfo (class)

```cpp
Schema key_schema_;
std::string name_;
std::unique_ptr<Index> index_;
index_oid_t index_oid_;
std::string table_name_;
const size_t key_size_;
```

观察上面的  `TableMetadata`  会发现少了索引，`IndexInfo`  就表示了这个索引，而 `Catalog` 的作用就是实现 `TableMetadata` 与 `IndexInfo` 关联起来，真正实现完整的表。

### Catalog (class)



```cpp
/** tables_ : table identifiers -> table metadata. Note that tables_ owns all table metadata. */
std::unordered_map<table_oid_t, std::unique_ptr<TableMetadata>> tables_;
/** names_ : table names -> table identifiers */
std::unordered_map<std::string, table_oid_t> names_;
/** The next table identifier to be used. */
std::atomic<table_oid_t> next_table_oid_{0};
/** indexes_: index identifiers -> index metadata. Note that indexes_ owns all index metadata */
std::unordered_map<index_oid_t, std::unique_ptr<IndexInfo>> indexes_;
/** index_names_: table name -> index names -> index identifiers */
std::unordered_map<std::string, std::unordered_map<std::string, index_oid_t>> index_names_;
/** The next index identifier to be used */
std::atomic<index_oid_t> next_index_oid_{0};
```

通过给定的类成员就能够推断出 `Catalog` 是如何关联 `TableMetadata` 和 `IndexInfo`  以及使用表名称/索引表名称关联 `TableMetadata`/`IndexInfo`。  

## Task2 - Executors

### 火山模型