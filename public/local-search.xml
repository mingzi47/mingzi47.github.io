<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CMU15-445 Lab3 : 支持查询</title>
    <link href="/2023/04/01/CMU15-445%20Lab3/"/>
    <url>/2023/04/01/CMU15-445%20Lab3/</url>
    
    <content type="html"><![CDATA[<h2 id="Task1-System-Catalog"><a href="#Task1-System-Catalog" class="headerlink" title="Task1 - System Catalog"></a>Task1 - System Catalog</h2><p>维护一个内部的目录来跟踪数据库内的元数据。</p><h3 id="Schema-class"><a href="#Schema-class" class="headerlink" title="Schema (class)"></a>Schema (class)</h3><p>表的结构信息，不包含表的实际数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t_user` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `phone` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `age` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE <span class="hljs-operator">=</span> InnoDB <span class="hljs-keyword">DEFAULT</span> <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> <span class="hljs-operator">=</span> ascii ROW_FORMAT <span class="hljs-operator">=</span> COMPACT;<br></code></pre></td></tr></table></figure><p>这些信息就由 <code>Schema</code> 来储存，真实数据数据会通过 <code>Tuple</code>  来储存。</p><p><code>TableHeap</code> 与 <code>Schema</code> 结合才是完整的表。</p><h4 id="Column-class"><a href="#Column-class" class="headerlink" title="Column (class)"></a>Column (class)</h4><p>表示列的信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 例如： column_name_ = &#x27;id&#x27; column_type_ = INTEGER ...</span><br>std::string column_name_;      <span class="hljs-comment">// column 名字</span><br>TypeId column_type_;           <span class="hljs-comment">// column 类型  INVALID, BOOLEAN, TINYINT, SMALLINT, INTEGER, BIGINT, DECIMAL, VARCHAR, TIMESTAMP </span><br><span class="hljs-type">uint32_t</span> variable_length_&#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">// 变量长度</span><br><span class="hljs-type">uint32_t</span> column_offset_&#123;<span class="hljs-number">0</span>&#125;;    <span class="hljs-comment">// 这一列在 `Tuple` 中的偏移量</span><br></code></pre></td></tr></table></figure><h3 id="TableHeap-class"><a href="#TableHeap-class" class="headerlink" title="TableHeap (class)"></a>TableHeap (class)</h3><p>表示磁盘上的物理表。</p><p>由多个 <code>TablePage</code> 组成，插入时从第一张 <code>TablePage</code> 开始，不能插入就尝试下一张，或者新建一张（没有下一张时），只到由空余的位置插入 <code>Tuple</code>。</p><p>更新，删除，查找通过  <code>Rid::GetPageId()</code> 可以轻松在 <code>BufferPoolManger</code> 中找到对应的 <code>TablePage</code>，并且通过 <code>Rid::GetSlotNum()</code> 在  <code>TablePage</code> 中找到对应的 <code>Tuple</code>。 </p><h4 id="TablePage-class"><a href="#TablePage-class" class="headerlink" title="TablePage (class)"></a>TablePage (class)</h4><p>继承 <code>Page</code> </p><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU15-445/Lab3/format.png" alt="format"></p><p>Header 的大小是 24 ，使用偏移量来获得 <code>Page</code> 中的每个值。</p><p><strong>插入 Tuple</strong></p><p>使用 <code>memcpy</code> 将 <code>Tuple::Data</code> 拷贝一份到<code>TablePage::Data</code> 对应的位置上。</p><p>同时会修改参数 <code>Rid</code> 做为这条 <code>Tuple</code> 的标志符，接下来更新、删除、查找这条 <code>Tuple</code> 都要依靠 <code>Rid</code>。</p><p><strong>更新 Tuple</strong></p><p>使用<code>memmove</code> 来将原来的 <code>TablePage::Data</code> 中要被更新的 <code>Tuple::Data</code> 移动到<code>TablePage::Data</code>后面。</p><p>重新设置<code>TablePage::Data</code> 中的 <code>Tuple::Data</code>的偏移量。</p><p><strong>删除 Tuple</strong></p><h5 id="MarkDelete"><a href="#MarkDelete" class="headerlink" title="MarkDelete"></a>MarkDelete</h5><p>只是标记为被删除，实际 <code>TupleCount</code> 和 <code>free_space_pointer</code> 都没有被改变，之后可以通过 <code>TablePage::RollbackDelete(const RID &amp;rid,...)</code> 来恢复。</p><h5 id="ApplyDelete"><a href="#ApplyDelete" class="headerlink" title="ApplyDelete"></a>ApplyDelete</h5><p>使用 <code>memmove</code> 将内容移除，不可恢复，删除后同样需要设置 <code>TablePage::Data</code> 中的 <code>Tuple::Data</code>的偏移量。</p><h5 id="Tuple-class"><a href="#Tuple-class" class="headerlink" title="Tuple (class)"></a>Tuple (class)</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> allocated_;  <span class="hljs-comment">// 是否被分配了内存</span><br><span class="hljs-type">uint32_t</span> size_;   <span class="hljs-comment">// 被分配内存的大小</span><br><span class="hljs-type">char</span> *data_;      <span class="hljs-comment">// 被分配的内存（数据）</span><br></code></pre></td></tr></table></figure><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU15-445/Lab3/tuple_format.png" alt="format"></p><h5 id="Rid-class"><a href="#Rid-class" class="headerlink" title="Rid (class)"></a>Rid (class)</h5><p>通过 <code>Rid</code> 就能快速找到 <code>TablePage</code> 中的 <code>Tuple</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">page_id_t</span> page_id_&#123;INVALID_PAGE_ID&#125;;  <span class="hljs-comment">// 这个 `Tuple` 在哪页上</span><br><span class="hljs-type">uint32_t</span> slot_num_&#123;<span class="hljs-number">0</span>&#125;;                <span class="hljs-comment">// `TablePage` 中的偏移量</span><br></code></pre></td></tr></table></figure><h4 id="TableIterator-class"><a href="#TableIterator-class" class="headerlink" title="TableIterator (class)"></a>TableIterator (class)</h4><p>为 sequential scan TableHeap 提供的迭代器。</p><p><code>*TableIterator</code> 会返回一个 <code>Tuple</code> </p><p><code>TableIterator</code> 只会向前迭代，每次都是迭代一张表（而不是一张 <code>Page</code>，一张表可能有多个 <code>Page</code> 组成 ）。</p><h3 id="TableMetadata-class"><a href="#TableMetadata-class" class="headerlink" title="TableMetadata (class)"></a>TableMetadata (class)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Schema schema_;<br>std::string name_;<br>std::unique_ptr&lt;TableHeap&gt; table_;<br><span class="hljs-type">table_oid_t</span> oid_;<br></code></pre></td></tr></table></figure><p>将 <code>TableHeap</code> 与 <code>Schema</code> 封装起来组成完整的表，同时加入表名称 <code>name</code> 和表的标示号 <code>oid_</code> 来帮助 <code>Catalog</code> 管理多个表。</p><h3 id="IndexInfo-class"><a href="#IndexInfo-class" class="headerlink" title="IndexInfo (class)"></a>IndexInfo (class)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Schema key_schema_;<br>std::string name_;<br>std::unique_ptr&lt;Index&gt; index_;<br><span class="hljs-type">index_oid_t</span> index_oid_;<br>std::string table_name_;<br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> key_size_;<br></code></pre></td></tr></table></figure><p>观察上面的  <code>TableMetadata</code>  会发现少了索引，<code>IndexInfo</code>  就表示了这个索引，而 <code>Catalog</code> 的作用就是实现 <code>TableMetadata</code> 与 <code>IndexInfo</code> 关联起来，真正实现完整的表。</p><h3 id="Catalog-class"><a href="#Catalog-class" class="headerlink" title="Catalog (class)"></a>Catalog (class)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/** tables_ : table identifiers -&gt; table metadata. Note that tables_ owns all table metadata. */</span><br>std::unordered_map&lt;<span class="hljs-type">table_oid_t</span>, std::unique_ptr&lt;TableMetadata&gt;&gt; tables_;<br><span class="hljs-comment">/** names_ : table names -&gt; table identifiers */</span><br>std::unordered_map&lt;std::string, <span class="hljs-type">table_oid_t</span>&gt; names_;<br><span class="hljs-comment">/** The next table identifier to be used. */</span><br>std::atomic&lt;<span class="hljs-type">table_oid_t</span>&gt; next_table_oid_&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-comment">/** indexes_: index identifiers -&gt; index metadata. Note that indexes_ owns all index metadata */</span><br>std::unordered_map&lt;<span class="hljs-type">index_oid_t</span>, std::unique_ptr&lt;IndexInfo&gt;&gt; indexes_;<br><span class="hljs-comment">/** index_names_: table name -&gt; index names -&gt; index identifiers */</span><br>std::unordered_map&lt;std::string, std::unordered_map&lt;std::string, <span class="hljs-type">index_oid_t</span>&gt;&gt; index_names_;<br><span class="hljs-comment">/** The next index identifier to be used */</span><br>std::atomic&lt;<span class="hljs-type">index_oid_t</span>&gt; next_index_oid_&#123;<span class="hljs-number">0</span>&#125;;<br></code></pre></td></tr></table></figure><p>通过给定的类成员就能够推断出 <code>Catalog</code> 是如何关联 <code>TableMetadata</code> 和 <code>IndexInfo</code>  以及使用表名称/索引表名称关联 <code>TableMetadata</code>/<code>IndexInfo</code>。  </p><h2 id="Task2-Executors"><a href="#Task2-Executors" class="headerlink" title="Task2 - Executors"></a>Task2 - Executors</h2><h3 id="火山模型"><a href="#火山模型" class="headerlink" title="火山模型"></a>火山模型</h3>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lab</tag>
      
      <tag>CMU15-445</tag>
      
      <tag>火山模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cpp线程池实现</title>
    <link href="/2023/03/12/Cpp%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/03/12/Cpp%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>基于生产者-消费者模型的线程池。</p><h2 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h2><p><img src="/images/Cpp/Cpp%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0/ThreadPool.png" alt="线程池整体设计"></p><p>线程池由两部分组成 存放线程的容器(ThreadPool) 和 一个任务队列(Tasks queue)。</p><p>容器中的线程都做相同的事情：</p><ul><li>从任务队列中获取一个任务。</li><li>执行这个任务。</li></ul><p>这些线程会一直重复这两个动作。</p><p>例如, 图中 id 为 1，4 的线程已经获得了一个任务，接下来它们要执行这个任务, 然后继续从任务队列中获取任务…</p><p>id 为 2, 3, 5 的线程正在从任务队列获得一个任务…</p><ul><li>会有多个线程访问任务队列，因此任务队列必须要支持并发。</li><li>每个线程会一直运行直到线程池关闭，从任务队列获取一个任务，执行，不断重复这个过程，如果不能获取一个任务(任务队列中可能没有任务了)，就要阻塞在获取任务这一步，直到获取了任务或线程池关闭。</li></ul><h2 id="支持并发的队列"><a href="#支持并发的队列" class="headerlink" title="支持并发的队列"></a>支持并发的队列</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeQueue</span> &#123;<br><span class="hljs-keyword">private</span>:<br>  std::queue&lt;T&gt; que_;<br>  std::shared_mutex mutex_;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T &amp;t)</span></span>;<br>  <span class="hljs-function">T <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>; <br>&#125;;<br></code></pre></td></tr></table></figure><p>使用读写锁对 <code>std::queue</code> 做了封装。</p><h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> SafeQueue&lt;T&gt;::<span class="hljs-built_in">push</span>(T &amp;t) &#123;<br>    <span class="hljs-function">std::unique_lock <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    que_.<span class="hljs-built_in">emplace</span>(t);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>T SafeQueue&lt;T&gt;::<span class="hljs-built_in">pop</span>() &#123;<br>    <span class="hljs-function">std::unique_lock <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    T ret = que_.<span class="hljs-built_in">front</span>();<br>    que_.<span class="hljs-built_in">pop</span>();<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">size_t</span> SafeQueue&lt;T&gt;::<span class="hljs-built_in">size</span>() &#123;<br>    <span class="hljs-function">std::shared_lock <span class="hljs-title">lock</span><span class="hljs-params">(mutex_)</span></span>;<br>    <span class="hljs-keyword">return</span> que_.<span class="hljs-built_in">size</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线程容器"><a href="#线程容器" class="headerlink" title="线程容器"></a>线程容器</h2><p>线程从任务队列获取任务后执行的过程的模型是生产者-消费者。</p><p>因此需要一个条件变量 <code>std::condition_variable</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadWorker</span> &#123;<br>  <span class="hljs-keyword">private</span>:<br>    ThreadPool *pool_;<br>    <span class="hljs-type">size_t</span> thread_id_;<br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ThreadWorker</span>(ThreadPool *pool, <span class="hljs-type">size_t</span> thread_id_)<br>        : <span class="hljs-built_in">pool_</span>(pool), <span class="hljs-built_in">thread_id_</span>(thread_id_) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span></span>;<br>  &#125;;<br><br>  <span class="hljs-type">size_t</span> threads_;<br>  <span class="hljs-type">bool</span> shutdown_;<br>  SafeQueue&lt;std::function&lt;<span class="hljs-type">void</span>()&gt;&gt; tasks_;<br>  std::vector&lt;std::thread&gt; works_;<br>  std::condition_variable condition_;<br>  std::mutex mutex_;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">ThreadPool</span>(<span class="hljs-type">size_t</span> threads = <span class="hljs-number">2</span>) &#123; <span class="hljs-built_in">init</span>(threads); &#125;;<br>  <span class="hljs-built_in">ThreadPool</span>(<span class="hljs-type">const</span> ThreadPool &amp;other) = <span class="hljs-keyword">delete</span>;<br>  <span class="hljs-built_in">ThreadPool</span>(ThreadPool &amp;&amp;other) = <span class="hljs-keyword">delete</span>;<br>  ThreadPool &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> ThreadPool &amp;other) = <span class="hljs-keyword">delete</span>;<br>  ThreadPool &amp;<span class="hljs-keyword">operator</span>=(ThreadPool &amp;&amp;other) = <span class="hljs-keyword">delete</span>;<br>  ~<span class="hljs-built_in">ThreadPool</span>() &#123; <span class="hljs-built_in">shutdown</span>(); &#125;;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">size_t</span> threads)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span>... Arg&gt;<br>  <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">submit</span><span class="hljs-params">(F &amp;&amp;f, Arg &amp;&amp;...args)</span> -&gt; std::future&lt;<span class="hljs-title">decltype</span><span class="hljs-params">(f(args...))</span>&gt;</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在构造函数中调用了 <code>init</code> 来提升易用性。</p><p>初始化时就把需要使用到的线程数量都启动起来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThreadPool::init</span><span class="hljs-params">(<span class="hljs-type">size_t</span> threads)</span> </span>&#123;<br>  threads_ = threads;<br>  shutdown_ = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">while</span> (tasks_.<span class="hljs-built_in">size</span>() != <span class="hljs-number">0</span>) &#123;<br>    tasks_.<span class="hljs-built_in">pop</span>();<br>  &#125;<br>  &#123;<br>    std::vector&lt;std::thread&gt; tmp_works&#123;&#125;;<br>    works_.<span class="hljs-built_in">swap</span>(tmp_works);<br>  &#125;<br>  works_.<span class="hljs-built_in">reserve</span>(threads_);<br>  works_.<span class="hljs-built_in">resize</span>(threads_);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; threads_; ++i) &#123;<br>    works_[i] = std::<span class="hljs-built_in">thread</span>([<span class="hljs-keyword">this</span>] &#123;<br>      std::function&lt;<span class="hljs-built_in">void</span>()&gt; func;<br>      <span class="hljs-keyword">for</span> (;;) &#123;<br>        &#123;<br>          std::unique_lock <span class="hljs-built_in">lock</span>(mutex_);<br>          condition_.<span class="hljs-built_in">wait</span>(lock, [<span class="hljs-keyword">this</span>] &#123;<br>            <span class="hljs-keyword">return</span> shutdown_ || tasks_.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>;<br>          &#125;);<br>          <span class="hljs-comment">// 当线程池已关闭且任务都完成了才真正关闭</span><br>          <span class="hljs-keyword">if</span> (shutdown_ &amp;&amp; tasks_.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>          &#125;<br>          func = std::<span class="hljs-built_in">move</span>(tasks_.<span class="hljs-built_in">pop</span>());<br>        &#125;<br>        <span class="hljs-built_in">func</span>();<br>      &#125;<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>关闭线程池时，要等待线程做完事（队列中的任务被全部完成, 在 ThreadWorker 中作判断）。</p><p>在析构函数中调用了 <code>shutdown()</code> , 利用 RAII 来实现自动关闭。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThreadPool::shutdown</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (shutdown_) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  shutdown_ = <span class="hljs-literal">true</span>;<br>  condition_.<span class="hljs-built_in">notify_all</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; threads_; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (works_[i].<span class="hljs-built_in">joinable</span>()) &#123;<br>      works_[i].<span class="hljs-built_in">join</span>();<br>    &#125;<br>  &#125;<br>  threads_ = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h3><p>任务是一个函数，可以是任意的返回类型，任意的参数。</p><p>使用可变参数模板来实现，支持函数，仿函数，Lambda, 以及任意多的参数。</p><p>有的任务在被执行过后会有返回值，需要使用 <code>std::future&lt;&gt;</code> 来获得这个值, 任务的返回值类型是多种多样的，所以使用 <code>decltype()</code> 来推导返回值的类型。</p><p>任务的多样性，没有办法直接确定一个类型来表示它们，对任务进行封装，使所有的任务都是 <code>void()</code> 类型。</p><p>任务进入队列后，要唤醒一个线程(告诉在阻塞的线程，队列中有了新的任务)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span>... Arg&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ThreadPool::submit</span><span class="hljs-params">(F &amp;&amp;f, Arg &amp;&amp;...args)</span> -&gt; std::future&lt;<span class="hljs-title">decltype</span><span class="hljs-params">(f(args...))</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// forward 完美转发</span><br>  std::function&lt;<span class="hljs-keyword">decltype</span>(f(args...))()&gt; func =<br>      std::<span class="hljs-built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Arg&gt;(args)...);<br><br>  <span class="hljs-keyword">auto</span> task_ptr =<br>      std::make_shared&lt;std::packaged_task&lt;<span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">f</span>(args...))()&gt;&gt;(func);<br><br>  std::function&lt;<span class="hljs-type">void</span>()&gt; wrap_task = [task_ptr] &#123; (*task_ptr)(); &#125;;<br><br>  tasks_.<span class="hljs-built_in">push</span>(wrap_task);<br><br>  condition_.<span class="hljs-built_in">notify_one</span>();<br><br>  <span class="hljs-keyword">return</span> task_ptr-&gt;<span class="hljs-built_in">get_future</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://paul.pub/cpp-concurrency/">C++ 并发编程 (从C++11到C++17)</a></p><p><a href="https://zclll.com/index.php/cpp/value_category.html">C++的右值引用、移动和值类别系统，你所需要的一切</a></p><p><a href="https://zhuanlan.zhihu.com/p/367309864">基于C++11实现的线程池</a></p><p><a href="https://github.com/progschj/ThreadPool">99行线程池</a></p>]]></content>
    
    
    <categories>
      
      <category>Cpp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线程池</tag>
      
      <tag>并发</tag>
      
      <tag>Cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++多态: 运行期多态与编译期多态</title>
    <link href="/2023/02/27/%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%A4%9A%E6%80%81%E4%B8%8E%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81/"/>
    <url>/2023/02/27/%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%A4%9A%E6%80%81%E4%B8%8E%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h2 id="运行期多态"><a href="#运行期多态" class="headerlink" title="运行期多态"></a>运行期多态</h2><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>运行期多态是关于面向对象的。</p><p>当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;Animal\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> : <span class="hljs-keyword">public</span> Animal &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;Dog\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Animal &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;Cat\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">(Animal* p)</span> </span>&#123;<br>  p-&gt;<span class="hljs-built_in">speak</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  Cat p1;<br>  Dog p2;<br>  <span class="hljs-built_in">speak</span>(&amp;p1);<br>  <span class="hljs-built_in">speak</span>(&amp;p2);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码运行结果为：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Cat</span><br><span class="hljs-attribute">Dog</span><br></code></pre></td></tr></table></figure><p>函数 <code>speak</code> 中基类指针 <code>Animal *p</code> 没有调用自己的 <code>speak</code> 函数, 而是调用实参对象的 <code>speak</code> 函数。</p><p>普通函数并不会存放于类中，但是虚函数会以<strong>虚函数表指针</strong>的形式存放与类中。</p><p>即使派生类指针转换为了基类指针，指针指向的内容并没有改变，其虚函数表还是指向原来的位置，因此在调用虚函数时，通过虚函数表来查找该调用哪个函数。</p><h3 id="多态实现的原理"><a href="#多态实现的原理" class="headerlink" title="多态实现的原理"></a>多态实现的原理</h3><h4 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h4><p>对类使用 <code>sizeof</code> 是不显示类中普通函数的大小的，但是虚函数是可以被显示的，不管有多少个虚函数，它们的大小都是 8 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>  <span class="hljs-type">int</span> a&#123;&#125;;<br>  <span class="hljs-type">int</span> b&#123;&#125;;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vf1</span><span class="hljs-params">()</span> </span>&#123;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;virtual function 1\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vf2</span><span class="hljs-params">()</span> </span>&#123;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;virtual function 2\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">vf3</span><span class="hljs-params">()</span> </span>&#123;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;virtual function 3\n&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>sizeof(B)</code> 是等于 16 (32 位操作系统是 12)。 </p><p>使用 <code>MSVC</code> 工具链查看对象模型： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## cl /d1 reportSingleClassLayout类名 文件名</span><br>cl /d1 reportSingleClassLayoutB main.cpp<br></code></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs 1c">class B size(<span class="hljs-number">16</span>):<br>        +---<br> <span class="hljs-number">0</span>      <span class="hljs-string">| &#123;vfptr&#125;</span><br> <span class="hljs-number">8</span>      <span class="hljs-string">| a</span><br><span class="hljs-number">12</span>      <span class="hljs-string">| b</span><br>        +---<br><br>B::$vftable@:<br>        <span class="hljs-string">| &amp;B_meta</span><br>        <span class="hljs-string">|  0</span><br> <span class="hljs-number">0</span>      <span class="hljs-string">| &amp;B::vf1</span><br> <span class="hljs-number">1</span>      <span class="hljs-string">| &amp;B::vf2</span><br> <span class="hljs-number">2</span>      <span class="hljs-string">| &amp;B::vf3</span><br></code></pre></td></tr></table></figure><p>结果很清晰，下面表示的是虚函数表的结构，虚函数表以指针形式存放在类中, 虚函数表中存放的也是指针。</p><p>尝试使用指针调用虚函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">int64_t</span>;<br><span class="hljs-keyword">using</span> vf = <span class="hljs-built_in">void</span>(*)();<br>B b&#123;&#125;;<br>i64 *vfptr = (i64*)&amp;b;  <span class="hljs-comment">// 类地址就是虚函数指针的地址</span><br>i64* vftable = (i64*)*vfptr; <br>((vf)vftable[<span class="hljs-number">0</span>])(); <span class="hljs-comment">// B::vf1</span><br>((vf)vftable[<span class="hljs-number">1</span>])(); <span class="hljs-comment">// B::vf2</span><br>((vf)vftable[<span class="hljs-number">2</span>])(); <span class="hljs-comment">// B::vf3</span><br></code></pre></td></tr></table></figure><p>输出为</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">virtual <span class="hljs-keyword">function</span> <span class="hljs-title">1</span><br>virtual <span class="hljs-keyword">function</span> <span class="hljs-title">2</span><br>virtual <span class="hljs-keyword">function</span> <span class="hljs-title">3</span><br></code></pre></td></tr></table></figure><p><img src="/images/Cpp/Cpp%E5%A4%9A%E6%80%81:%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%A4%9A%E6%80%81%E4%B8%8E%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81/%E5%A4%9A%E6%80%81-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E6%A8%A1%E5%9E%8B0.png"></p><p>是否会为每一个对象都创建一个虚表 ？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">int64_t</span>;<br><span class="hljs-keyword">using</span> vf = <span class="hljs-built_in">void</span>(*)();<br>B b&#123;&#125;, b1&#123;&#125;;<br>i64 *vfptr = (i64*)&amp;b;  <span class="hljs-comment">// 类地址就是虚函数指针的地址</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;b vfptr = &quot;</span> &lt;&lt; *vfptr &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;b1 vfptr = &quot;</span> &lt;&lt; *((i64*)&amp;b1) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br></code></pre></td></tr></table></figure><p>输出相同，<code>b</code> 和 <code>b1</code> 都指向了同一张虚表。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">b vfptr <span class="hljs-operator">=</span> <span class="hljs-number">140697380241528</span><br>b1 vfptr <span class="hljs-operator">=</span> <span class="hljs-number">140697380241528</span><br></code></pre></td></tr></table></figure><p><img src="/images/Cpp/Cpp%E5%A4%9A%E6%80%81:%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%A4%9A%E6%80%81%E4%B8%8E%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81/%E5%A4%9A%E6%80%81-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E6%A8%A1%E5%9E%8B1.png"></p><h4 id="单继承时的虚函数表"><a href="#单继承时的虚函数表" class="headerlink" title="单继承时的虚函数表"></a>单继承时的虚函数表</h4><p>查看实例代码中的虚函数表的内存地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">int64_t</span>;<br><span class="hljs-keyword">using</span> vf = <span class="hljs-built_in">void</span>(*)();<br>Animal p1;<br>Cat p2;<br>Dog p3;<br>i64 *p1_vfptr = (i64*)&amp;p1;<br>i64 *p2_vfptr = (i64*)&amp;p2;<br>i64 *p3_vfptr = (i64*)&amp;p3;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Animal vtable address = &quot;</span> &lt;&lt; *p1_vfptr &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Cat vtable address = &quot;</span> &lt;&lt; *p2_vfptr &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Dog vtable address = &quot;</span> &lt;&lt; *p3_vfptr &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>vf p1_speak_ptr = (vf)((i64*)*p1_vfptr)[<span class="hljs-number">0</span>];<br>vf p2_speak_ptr = (vf)((i64*)*p2_vfptr)[<span class="hljs-number">0</span>];<br>vf p3_speak_ptr = (vf)((i64*)*p3_vfptr)[<span class="hljs-number">0</span>];<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Animal speak address = &quot;</span> &lt;&lt; p1_speak_ptr &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Cat speak address = &quot;</span> &lt;&lt; p2_speak_ptr &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Dog speak address = &quot;</span> &lt;&lt; p3_speak_ptr &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br></code></pre></td></tr></table></figure><p><code>Animal</code>、<code>Cat</code> 和 <code>Dog</code> 的虚函数表位置各不相同，函数的地址也各不相同。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Animal vtable address <span class="hljs-operator">=</span> <span class="hljs-number">140702687674488</span><br>Cat vtable address <span class="hljs-operator">=</span> <span class="hljs-number">140702687673376</span><br>Dog vtable address <span class="hljs-operator">=</span> <span class="hljs-number">140702687674176</span><br>Animal speak address <span class="hljs-operator">=</span> <span class="hljs-number">00007</span>FF7E5B71555<br>Cat speak address <span class="hljs-operator">=</span> <span class="hljs-number">00007</span>FF7E5B71564<br>Dog speak address <span class="hljs-operator">=</span> <span class="hljs-number">00007</span>FF7E5B71569<br></code></pre></td></tr></table></figure><p>内存结构为：</p><p><img src="/images/Cpp/Cpp%E5%A4%9A%E6%80%81:%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%A4%9A%E6%80%81%E4%B8%8E%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81/%E5%A4%9A%E6%80%81-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E6%A8%A1%E5%9E%8B2.png"></p><p>但是这里使用了<strong>重写</strong>，重写会对内存结构产生影响吗?</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Animal\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> : <span class="hljs-keyword">public</span> Animal &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Dog\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Animal &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/*void speak() &#123;</span><br><span class="hljs-comment">        std::cout &lt;&lt; &quot;Cat\n&quot;;</span><br><span class="hljs-comment">    &#125;*/</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">(Animal* p)</span> </span>&#123;<br>    p-&gt;<span class="hljs-built_in">speak</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">/*Cat p1;</span><br><span class="hljs-comment">    Dog p2;</span><br><span class="hljs-comment">    speak(&amp;p1);</span><br><span class="hljs-comment">    speak(&amp;p2);*/</span><br>    <span class="hljs-keyword">using</span> i64 = <span class="hljs-type">int64_t</span>;<br>    <span class="hljs-keyword">using</span> vf = <span class="hljs-built_in">void</span>(*)();<br>    Animal p1;<br>    Cat p2;<br>    Dog p3;<br>    i64 *p1_vfptr = (i64*)&amp;p1;<br>    i64 *p2_vfptr = (i64*)&amp;p2;<br>    i64 *p3_vfptr = (i64*)&amp;p3;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Animal vtable address = &quot;</span> &lt;&lt; *p1_vfptr &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Cat vtable address = &quot;</span> &lt;&lt; *p2_vfptr &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Dog vtable address = &quot;</span> &lt;&lt; *p3_vfptr &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    vf p1_speak_ptr = (vf)((i64*)*p1_vfptr)[<span class="hljs-number">0</span>];<br>    vf p2_speak_ptr = (vf)((i64*)*p2_vfptr)[<span class="hljs-number">0</span>];<br>    vf p3_speak_ptr = (vf)((i64*)*p3_vfptr)[<span class="hljs-number">0</span>];<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Animal speak address = &quot;</span> &lt;&lt; p1_speak_ptr &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Cat speak address = &quot;</span> &lt;&lt; p2_speak_ptr &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Dog speak address = &quot;</span> &lt;&lt; p3_speak_ptr &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Animal vtable address <span class="hljs-operator">=</span> <span class="hljs-number">140700141011064</span><br>Cat vtable address <span class="hljs-operator">=</span> <span class="hljs-number">140700141009952</span><br>Dog vtable address <span class="hljs-operator">=</span> <span class="hljs-number">140700141010752</span><br>Animal speak address <span class="hljs-operator">=</span> <span class="hljs-number">00007</span>FF74DEC1555<br>Cat speak address <span class="hljs-operator">=</span> <span class="hljs-number">00007</span>FF74DEC1555<br>Dog speak address <span class="hljs-operator">=</span> <span class="hljs-number">00007</span>FF74DEC1569<br></code></pre></td></tr></table></figure><p><code>Cat</code> 与 <code>Animal</code> 都指向了同一个函数，但是这三个类都有自己的<strong>虚函数表</strong>。</p><p><code>Cat</code> 的对象模型为：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">class Cat       size(8):<br>        +---<br> 0      |<span class="hljs-string"> +--- (base class Animal)</span><br><span class="hljs-string"> 0      </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> &#123;vfptr&#125;</span><br><span class="hljs-string">        </span>|<span class="hljs-string"> +---</span><br><span class="hljs-string">        +---</span><br><span class="hljs-string"></span><br><span class="hljs-string">Cat::$vftable@:</span><br><span class="hljs-string">        </span>|<span class="hljs-string"> &amp;Cat_meta</span><br><span class="hljs-string">        </span>|<span class="hljs-string">  0</span><br><span class="hljs-string"> 0      </span>|<span class="hljs-string"> &amp;Animal::speak</span><br></code></pre></td></tr></table></figure><p>此时的内存模型为:</p><p><img src="/images/Cpp/Cpp%E5%A4%9A%E6%80%81:%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%A4%9A%E6%80%81%E4%B8%8E%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81/%E5%A4%9A%E6%80%81-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E6%A8%A1%E5%9E%8B3.png"></p><p>创建多个对象时的内存结构会发生改变吗？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Cat 的 speak 没有重写。</span><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">int64_t</span>;<br><span class="hljs-keyword">using</span> vf = <span class="hljs-built_in">void</span>(*)();<br>Animal p1;<br>Cat p2;<br>Dog p3;<br>Animal p11;<br>Cat p22;<br>Dog p33;<br>i64 *p1_vfptr = (i64*)&amp;p1;<br>i64 *p2_vfptr = (i64*)&amp;p2;<br>i64 *p3_vfptr = (i64*)&amp;p3;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Animal p1 vtable address = &quot;</span> &lt;&lt; *p1_vfptr &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Cat p2 vtable address = &quot;</span> &lt;&lt; *p2_vfptr &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Dog p3 vtable address = &quot;</span> &lt;&lt; *p3_vfptr &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>vf p1_speak_ptr = (vf)((i64*)*p1_vfptr)[<span class="hljs-number">0</span>];<br>vf p2_speak_ptr = (vf)((i64*)*p2_vfptr)[<span class="hljs-number">0</span>];<br>vf p3_speak_ptr = (vf)((i64*)*p3_vfptr)[<span class="hljs-number">0</span>];<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Animal p1 speak address = &quot;</span> &lt;&lt; p1_speak_ptr &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Cat p2 speak address = &quot;</span> &lt;&lt; p2_speak_ptr &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Dog p3 speak address = &quot;</span> &lt;&lt; p3_speak_ptr &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>i64* p11_vfptr = (i64*)&amp;p11;<br>i64* p22_vfptr = (i64*)&amp;p22;<br>i64* p33_vfptr = (i64*)&amp;p33;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Animal p11 vtable address = &quot;</span> &lt;&lt; *p11_vfptr &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Cat p22 vtable address = &quot;</span> &lt;&lt; *p22_vfptr &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Dog p33 vtable address = &quot;</span> &lt;&lt; *p33_vfptr &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>vf p11_speak_ptr = (vf)((i64*)*p11_vfptr)[<span class="hljs-number">0</span>];<br>vf p22_speak_ptr = (vf)((i64*)*p22_vfptr)[<span class="hljs-number">0</span>];<br>vf p33_speak_ptr = (vf)((i64*)*p33_vfptr)[<span class="hljs-number">0</span>];<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Animal p11 speak address = &quot;</span> &lt;&lt; p11_speak_ptr &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Cat p22 speak address = &quot;</span> &lt;&lt; p22_speak_ptr &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Dog p33 speak address = &quot;</span> &lt;&lt; p33_speak_ptr &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Animal p1 vtable address <span class="hljs-operator">=</span> <span class="hljs-number">140702695145024</span><br>Cat p2 vtable address <span class="hljs-operator">=</span> <span class="hljs-number">140702695145096</span><br>Dog p3 vtable address <span class="hljs-operator">=</span> <span class="hljs-number">140702695145064</span><br>Animal p1 speak address <span class="hljs-operator">=</span> <span class="hljs-number">00007</span>FF7E629123A<br>Cat p2 speak address <span class="hljs-operator">=</span> <span class="hljs-number">00007</span>FF7E629123A<br>Dog p3 speak address <span class="hljs-operator">=</span> <span class="hljs-number">00007</span>FF7E62910B4<br>Animal p11 vtable address <span class="hljs-operator">=</span> <span class="hljs-number">140702695145024</span><br>Cat p22 vtable address <span class="hljs-operator">=</span> <span class="hljs-number">140702695145096</span><br>Dog p33 vtable address <span class="hljs-operator">=</span> <span class="hljs-number">140702695145064</span><br>Animal p11 speak address <span class="hljs-operator">=</span> <span class="hljs-number">00007</span>FF7E629123A<br>Cat p22 speak address <span class="hljs-operator">=</span> <span class="hljs-number">00007</span>FF7E629123A<br>Dog p33 speak address <span class="hljs-operator">=</span> <span class="hljs-number">00007</span>FF7E62910B4<br></code></pre></td></tr></table></figure><p>同一个类还是共用一张虚函数表，此时的内存结构为：</p><p><img src="/images/Cpp/Cpp%E5%A4%9A%E6%80%81:%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%A4%9A%E6%80%81%E4%B8%8E%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81/%E5%A4%9A%E6%80%81-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E6%A8%A1%E5%9E%8B4.png"></p><h4 id="虚函数表的总结"><a href="#虚函数表的总结" class="headerlink" title="虚函数表的总结"></a>虚函数表的总结</h4><ol><li>同一个类只会创建一张虚函数表。</li><li>存在继承关系时，派生类没有<strong>重写</strong>虚函数，虚函数表中的指针指向基类的函数。重写后，会指向一个新的函数。</li></ol><h2 id="编译期多态"><a href="#编译期多态" class="headerlink" title="编译期多态"></a>编译期多态</h2><p>CRTP 全称是curious recurring template pattern, 可以用来在基类暴露接口且派生类实现对应接口时实现“编译期多态”。</p><p>之前的代码可以被更改为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">static_cast</span>&lt;T*&gt;(<span class="hljs-keyword">this</span>)-&gt;<span class="hljs-built_in">speak</span>(); &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> : <span class="hljs-keyword">public</span> Animal&lt;Dog&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Dog\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Animal&lt;Cat&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Cat\n&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">(Animal&lt;T&gt; *p)</span> </span>&#123; p-&gt;<span class="hljs-built_in">speak</span>(); &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  Cat p1&#123;&#125;;<br>  Dog p2&#123;&#125;;<br>  <span class="hljs-built_in">speak</span>(&amp;p1);<br>  <span class="hljs-built_in">speak</span>(&amp;p2);<br>&#125;<br></code></pre></td></tr></table></figure><p>派生类必须要实现这个函数才行，看起来 CRTP 并不是很有用。</p><p>当需要返回一个 指向 <code>this</code> 的 <code>shared_ptr</code> 时, 才应该使用 CRTP 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123;<br>  <span class="hljs-function">std::shared_ptr&lt;A&gt; <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">shared_ptr</span>&lt;A&gt;(<span class="hljs-keyword">this</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::shared_ptr&lt;A&gt; a = std::<span class="hljs-built_in">make_shared</span>&lt;A&gt;();<br>  <span class="hljs-keyword">auto</span> b = a-&gt;<span class="hljs-built_in">get</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight irpf90"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs irpf90"><span class="hljs-keyword">double</span> <span class="hljs-keyword">free</span> or corruption (<span class="hljs-keyword">out</span>)<br></code></pre></td></tr></table></figure><p>多次释放了 <code>A</code>, 通过使用 <code>use_count()</code> 查看引用计数个数发现，计数并没有增加，仍为 1，但是有两个指针指向了同一个对象。</p><p>将类改为 ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> : std::enable_shared_from_this&lt;A&gt; &#123;<br>  <span class="hljs-function">std::shared_ptr&lt;A&gt; <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_from_this</span>();<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这时就可以正常运行了。</p><p><strong>参考</strong></p><p><a href="https://en.cppreference.com/w/cpp/language/crtp">CRTP cppreference</a></p><p><a href="https://en.cppreference.com/w/cpp/memory/enable_shared_from_this">std::enable_shared_from_this cppreference</a></p>]]></content>
    
    
    <categories>
      
      <category>Cpp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多态</tag>
      
      <tag>面向对象</tag>
      
      <tag>模板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU15-445 Lab2 : 可高并发的 B+ 树索引</title>
    <link href="/2023/02/26/CMU15-445%20Lab2/"/>
    <url>/2023/02/26/CMU15-445%20Lab2/</url>
    
    <content type="html"><![CDATA[<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+ 树"></a>B+ 树</h2><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU15-445/B+%E6%A0%91%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/BPlusTree.png" alt="B+ 树"></p><p>上图表示的是一颗四阶 B+ 树，四阶表示每个节点最多存四个 K-V 对。</p><p>B+ 树的叶子节点分为三类：</p><ul><li>根节点</li><li>内部节点</li><li>叶子节点</li></ul><p><strong>根节点</strong>可以是内部节点也可使叶子节点。</p><p>B+ 树的每个节点不仅有最大容量，也有最小容量(最小容量 = 最大容量的一半, 下取整)，低于最小容量的节点会想方法让自己的节点树增加(在 删除 中详细讲解)，<strong>根节点</strong>没有最小容量限制。</p><p>每个节点中的数据是有序的，按照 K 值排序。</p><p><strong>内部节点</strong>是不存储真实数据的，而是存储子树的位置。上图中的 3 号内部节点，他已经存储了 3 个 K-V 对，第一个 K-V 对指向 $K &lt; 4$ 的子树的位置，第二个 K-V 指向 $4 \leq K &lt; 6$ 的子树位置，第三个 K-V 对指向 $ 6 \leq K$ 的子树位置。</p><p>内部节点的 K 实际是一个范围。</p><p><strong>叶子节点</strong>存储了真实的数据(也可以是指向数据的地址)。同时，叶子节点也会指向下一个叶子节点，像链表一样。</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>因为信息存放在叶子节点中，只要找到 <code>key</code> 所在的叶子节点, 递归查找即可。节点中的 <code>key</code> 是有序的，查找下一个节点可以借助二分查找。</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>B+ 树的插入是自下而上的。</p><ol><li>根据 <code>key</code> 找到它该插入的叶子节点。</li><li>插入数据到这个叶子节点，判断这个叶子节点是否等于最大容量，若果是的话要进行分裂操作，否则什么也不做(也可以先判断再插入)。</li><li>分裂操作，将这个节点中的一半分到一个新节点，创建了新节点也要向父节点去插入一对 K-V 来确保父节点表示的范围正确, 这对 K-V 是新节点的第一对 K-V, 如果插入后的父节点等于最大容量，同样要进行分裂操作。(如果要分裂的是叶子节点，还需要更新下一个节点)。</li></ol><p>现在考虑在一个 5 阶的 B+ 树上插入一个 (5, V) 。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU15-445/B+%E6%A0%91%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/insert1.png" alt="B+树中的数据小于阶数时"></p><p>插入后这个节点的大小就等于最大容量了，要进行分裂操作。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU15-445/B+%E6%A0%91%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/insert2.png" alt="插入 4 时造成了 `split`, 同时产生了新的根节点"></p><p>分裂之后，我们需要向它的父节点插入一个 K-V。</p><p>自下而上的插入，当还没有分裂时，根节点是一个叶子节点，同时大小为 1 的节点是不表示的，再没有插入 (5, V) 时，节点 3 是不表示的。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除操作也是自下而上的。</p><ol><li>删除一个 K-V 后，如果这个节点的大小严格小于最小容量，需要进行合并操作。</li><li>优先考虑从同一个父亲节点的兄弟节点中拿走一个 K-V，被拿走的节点大小必须是严格大于节点的最小容量的。</li><li>如果不能进行拿走节点的操作，就要考虑把自己的所有 K-V 插入到周围的节点中，这个节点也就被删除了，对于它的父节点也要删除对应的 K-V, 接着考虑父节点是否需要进行合并操作</li></ol><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU15-445/B+%E6%A0%91%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/insert2.png" alt="删除前"></p><p>删除 <code>key</code> 值为 2 的 K-V。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU15-445/B+%E6%A0%91%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/erase1.png" alt="删除后"></p><p>这时节点 1 的大小严格小于最小容量，尝试从节点 2 中拿一个节点，刚好 2 号节点的大小是严格大于最小容量的。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU15-445/B+%E6%A0%91%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/erase2.png" alt="因为节点 1 的数据个数小于最小限制，因此需要 `merge`"></p><p>只能拿走 2 号节点的第一个 K-V，因此还需要对父节点中对应的 K-V 进行修改。</p><p>考虑删除 <code>key</code> 值为 3 的 K-V。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU15-445/B+%E6%A0%91%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/erase3.png"></p><p>节点 1 的又需要进行合并操作，这时的 2 号节点不能提供一个 K-V 给 1 号节点了， 尝试将 2 号节点的 K-V 都移动到 1 号节点 (或者 1 移动到 2)。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU15-445/B+%E6%A0%91%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/erase4.png"></p><p>2 号节点不存在了，要删除父节点中对应的 K-V。</p><p>父节点 3 只剩一对 K-V 了，如果它可以进行合并操作，就要对他进行这个操作，这里不能进行操作。父节点 3 也没有存在的意义，删除节点 3 只保留节点 1 。</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>最简单的想法是让 插入、删除、搜索 这三个节点共用一把读写锁，这样效率实在太低了。</p><p>采用特殊的加锁方式 “latch crabbing”, 像螃蟹走路一样进行加锁。先锁住父节点，在锁住孩子节点，如果孩子节点，如果孩子节点是安全的，就解开父节点的锁。</p><h3 id="搜索-1"><a href="#搜索-1" class="headerlink" title="搜索"></a>搜索</h3><p>孩子节点一定是安全的，搜索不会改变任何节点的大小。</p><p>搜索 <code>key</code> 值为 12 的 K-V</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU15-445/B+%E6%A0%91%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/2search1.png"></p><p>锁住孩子节点。<br><img src="">/images/数据库/CMU15-445/B+树与高并发/2search2.png)</p><p>释放父节点。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU15-445/B+%E6%A0%91%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/2search3.png"></p><p>递归进行即可。</p><h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><p>插入操作会改变节点的大小，当前节点大小 + 1 等于节点的最大容量，这个节点就是不安全的，如果对这个节点进行插入操作，它的父节点也要进行插入操作，因此不能释放它的父节点的写锁。</p><p>如果在下面遇到了一个安全的节点，之前所有的上锁的节点都可以解锁了，包括之前不安全的节点，因为这个安全的节点保证了上面的节点不会被下面的操作影响。</p><p>插入 (2, V)， 先锁住根节点。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU15-445/B+%E6%A0%91%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/2insert1.png"></p><p>再锁住子节点 3，并判断他是否安全。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU15-445/B+%E6%A0%91%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/2insert2.png"></p><p>子节点 3 并不安全，不释放节点 5 的锁，继续递归对节点 1 加锁。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU15-445/B+%E6%A0%91%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/2insert3.png"></p><p>节点 1 是安全的，释放节点3，5 的锁。</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU15-445/B+%E6%A0%91%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/2insert4.png"></p><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><p>与插入操作类似，虽然它有可能会更改多个节点，但是锁住父节点就没什么影响了。</p><p>判断节点是否安全的条件为，节点大小严格大于最小容量的节点是安全的，否则是不安全的。</p><h2 id="Bustub-中的-Latch"><a href="#Bustub-中的-Latch" class="headerlink" title="Bustub 中的 Latch"></a>Bustub 中的 Latch</h2><h3 id="Lock-与-Latch"><a href="#Lock-与-Latch" class="headerlink" title="Lock 与 Latch"></a>Lock 与 Latch</h3><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU15-445/B+%E6%A0%91%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91/lock-latch.png" alt="Lock and Latch"></p><h3 id="乐观的实现"><a href="#乐观的实现" class="headerlink" title="乐观的实现"></a>乐观的实现</h3><p><code>insert</code> 与 <code>delete</code> 时, 都会锁住先锁住根节点，这时其他线程不能读也不能写, 根节点的写锁成为了并发的瓶颈。</p><p>很多操作是不需要 <code>split</code> 与 <code>merge</code> 操作的, 也就是说在这些操作中叶子节点不会对父节点造成影响，这种情况下对于内部节点只需要使用读锁就可以，也不需要对是内部节点的子节点进行安全判断，但是需要对是叶子节点的子节点进行安全判断，如果不安全，就要从根节点重新开始上写锁。</p><p>我们假设了大多数的操作是不需要 <code>split</code> 与 <code>merge</code> 的，因此这种乐观的实现方式可以带来更高的效率可以得到很大提升。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">B+ 树演示网站</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lab</tag>
      
      <tag>CMU15-445</tag>
      
      <tag>B+树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU15-445 Lab1 : 缓冲池</title>
    <link href="/2023/02/22/CMU15-445%20Lab1/"/>
    <url>/2023/02/22/CMU15-445%20Lab1/</url>
    
    <content type="html"><![CDATA[<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p><a href="https://15445.courses.cs.cmu.edu/fall2020/project1/">2020年的CMU15-445</a> 的 Lab1 需要实现 LRU 算法。</p><p><a href="https://15445.courses.cs.cmu.edu/fall2022/project1/">2022年的CMU15-445</a> 的 Lab1 需要实现 LRU-K 算法。</p><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><blockquote><p>LRU是 Least Recently Used 的缩写，即最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最少使用的页面予以淘汰。</p></blockquote><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><p>LRU 的定义相当简单，实现时，只需要维护一个列表来记录最近使用的页面的顺序。</p><p>对于这个列表，需要能够用常数级别的时间复杂度将列表中的一个元素移动到列表一边 (最近使用顺序的更新)。</p><p>双端链表在知道节点指针是删除一个元素的时间复杂度为 O(1), 节点指针可以通过哈希映射的方式快速获得。</p><p>假设内存可以容纳 6 个页，按照 1，2，3，4，5 的顺序访问，双端链表是这样记录的：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU15-445/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2/LRU0.png" alt="图 1"></p><p>head 就是访问时间最早的, 如果容量满了，就要取出 head 。</p><p>继续访问 6，7：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU15-445/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2/LRU1.png" alt="访问 6"></p><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU15-445/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2/LRU2.png" alt="访问 7"></p><p>访问 7 的时候容量满了，将页面上次访问到现在时间最长的拿出来（id 1，我们按照访问顺序将它们存在了双端链表中，因此 head 就是要被替换的)。</p><p>这时访问 3 会发生什么：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU15-445/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2/LRU3.png" alt="访问 3"></p><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU15-445/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2/LRU4.png" alt="访问 3"></p><p>先取出 3 所在的节点，然后插入到列表尾部，这样双端队列就是按照上次访问到现在的时间排好序的。</p><p>取出 3 的操作就要用到哈希表将页面 id 与节点地址映射起来，这样替换操作就是一个常数的时间复杂度。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存 - 力扣（LeetCode）</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">list_node</span> &#123;<br>    <span class="hljs-type">int</span> key_;<br>    <span class="hljs-type">int</span> value_;<br>    std::weak_ptr&lt;list_node&gt; prev_;<br>    std::shared_ptr&lt;list_node&gt; next_;<br>    <span class="hljs-built_in">list_node</span>(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value, std::shared_ptr&lt;list_node&gt; prev = <span class="hljs-literal">nullptr</span>,<br>              std::shared_ptr&lt;list_node&gt; next = <span class="hljs-literal">nullptr</span>)<br>        : key_&#123;key&#125;, value_&#123;value&#125;, <span class="hljs-built_in">prev_</span>(prev), <span class="hljs-built_in">next_</span>(next) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_value</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> value_; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_key</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> key_; &#125;<br>  &#125;;<br><br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">list</span> &#123;<br>  <span class="hljs-keyword">private</span>:<br>    std::shared_ptr&lt;list_node&gt; begin_;<br>    std::shared_ptr&lt;list_node&gt; end_;<br>    <span class="hljs-type">int</span> size_;<br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">list</span>()<br>        : <span class="hljs-built_in">begin_</span>(std::<span class="hljs-built_in">make_shared</span>&lt;list_node&gt;(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)),<br>          <span class="hljs-built_in">end_</span>(std::<span class="hljs-built_in">make_shared</span>&lt;list_node&gt;(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)), <span class="hljs-built_in">size_</span>(<span class="hljs-number">0</span>) &#123;<br>      begin_-&gt;next_ = end_;<br>      end_-&gt;prev_ = begin_;<br>    &#125;<br><br>    <span class="hljs-function">std::shared_ptr&lt;list_node&gt; <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>      end_-&gt;prev_.<span class="hljs-built_in">lock</span>()-&gt;next_ =<br>          std::<span class="hljs-built_in">make_shared</span>&lt;list_node&gt;(key, value, end_-&gt;prev_.<span class="hljs-built_in">lock</span>(), end_);<br>      end_-&gt;prev_ = end_-&gt;prev_.<span class="hljs-built_in">lock</span>()-&gt;next_;<br>      ++size_;<br>      <span class="hljs-keyword">return</span> end_-&gt;prev_.<span class="hljs-built_in">lock</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_front</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">if</span> (begin_-&gt;next_ == end_)<br>        <span class="hljs-keyword">return</span>;<br>      <span class="hljs-built_in">pop</span>(begin_-&gt;next_);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(std::shared_ptr&lt;list_node&gt; del_node)</span> </span>&#123;<br>      del_node-&gt;next_-&gt;prev_ = del_node-&gt;prev_;<br>      del_node-&gt;prev_.<span class="hljs-built_in">lock</span>()-&gt;next_ = del_node-&gt;next_;<br>      --size_;<br>    &#125;<br><br>    <span class="hljs-function">std::shared_ptr&lt;list_node&gt; <span class="hljs-title">begin</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> begin_-&gt;next_; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> size_; &#125;<br>  &#125; key_;<br><br>  std::unordered_map&lt;<span class="hljs-type">int</span>, std::shared_ptr&lt;list_node&gt;&gt; map_&#123;&#125;;<br>  <span class="hljs-type">int</span> capacity_;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity) : <span class="hljs-built_in">capacity_</span>(capacity) &#123;&#125;<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (map_.<span class="hljs-built_in">count</span>(key) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> value = map_[key]-&gt;<span class="hljs-built_in">get_value</span>();<br>    key_.<span class="hljs-built_in">pop</span>(map_[key]);<br>    map_.<span class="hljs-built_in">erase</span>(key);<br>    map_[key] = key_.<span class="hljs-built_in">push_back</span>(key, value);<br>    <span class="hljs-keyword">return</span> value;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (map_.<span class="hljs-built_in">count</span>(key) != <span class="hljs-number">0</span>) &#123;<br>      key_.<span class="hljs-built_in">pop</span>(map_[key]);<br>      map_.<span class="hljs-built_in">erase</span>(key);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (capacity_ &lt;= key_.<span class="hljs-built_in">size</span>()) &#123;<br>      map_.<span class="hljs-built_in">erase</span>(key_.<span class="hljs-built_in">begin</span>()-&gt;<span class="hljs-built_in">get_key</span>());<br>      key_.<span class="hljs-built_in">pop_front</span>();<br>    &#125;<br>    map_[key] = key_.<span class="hljs-built_in">push_back</span>(key, value);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="LRU-K"><a href="#LRU-K" class="headerlink" title="LRU-K"></a>LRU-K</h3><blockquote><p>The LRU-K algorithm evicts a frame whose backward k-distance is maximum of all frames in the replacer. Backward k-distance is computed as the difference in time between current timestamp and the timestamp of kth previous access. A frame with less than k historical accesses is given +inf as its backward k-distance. When multipe frames have +inf backward k-distance, the replacer evicts the frame with the earliest timestamp.</p></blockquote><h4 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h4><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU15-445/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2/lruk1.png" alt="LRU-K"></p><p>LRU-K 同时存在两种缓存：</p><ul><li>访问次数不到 K 次，替换时被优先替换</li><li>访问了至少 K 次, 替换时，没有第一种时，才会被替换</li></ul><p>K-distance : </p><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU15-445/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2/k-distance.png" alt="K-distance 定义"></p><p>下图为一个页面的访问记录:</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU15-445/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2/lruk0.png" alt="页面的访问记录"></p><p>当 K = 2, 这个页面的 K-distance = 9</p><p>当 K = 4, 这个页面的 K-distance = 3</p><p>当 K = 6, 这个页面的 K-distance = $\inf$</p><p>第二种缓存的替换是依赖 K-distance 的，每次把 K-distance 小的替换出去（访问时间更久的)。</p><p>显然，LRU 是 LRU-1。</p><p>第二种缓存是要排序的，因此没法 O(1) 实现,不能保证新的一次访问会让一个页面的 K-distance 是最大的，可能需要插入的缓存中间。</p><p>CMU15-445 中第一种缓存的替换策略为替换第一次访问时间距今最久的页面（FIFO), 也可已使用最后一次访问时间距今来判断（LRU）。</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUKReplacer</span> &#123;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Page</span> &#123;<br>    std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; value_;<br>    <span class="hljs-type">int</span> count_;<br>    std::list&lt;<span class="hljs-type">int</span>&gt; history_;<br>    <span class="hljs-built_in">Page</span>(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value, <span class="hljs-type">int</span> count = <span class="hljs-number">1</span>)<br>        : <span class="hljs-built_in">value_</span>(key, value), <span class="hljs-built_in">count_</span>(count) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_k</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> count_ &lt;= <span class="hljs-number">0</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">record</span><span class="hljs-params">(<span class="hljs-type">int</span> time)</span> </span>&#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_k</span>())<br>        history_.<span class="hljs-built_in">pop_front</span>();<br>      history_.<span class="hljs-built_in">push_back</span>(time);<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">is_k</span>())<br>        --count_;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">k_distance</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> history_.<span class="hljs-built_in">front</span>();<br>    &#125;<br>  &#125;;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> capacity_;<br>  <span class="hljs-type">int</span> k_;<br>  <span class="hljs-type">int</span> cur_time_&#123;<span class="hljs-number">0</span>&#125;;<br><br>  std::list&lt;Page&gt; k_que_;<br>  std::unordered_map&lt;<span class="hljs-type">int</span>, std::list&lt;Page&gt;::iterator&gt; k_map_;<br>  std::list&lt;Page&gt; inf_que_;<br>  std::unordered_map&lt;<span class="hljs-type">int</span>, std::list&lt;Page&gt;::iterator&gt; inf_map_; <span class="hljs-comment">//FIFO</span><br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">LRUKReplacer</span>(<span class="hljs-type">int</span> capacity, <span class="hljs-type">int</span> k) : <span class="hljs-built_in">capacity_</span>(capacity), <span class="hljs-built_in">k_</span>(k) &#123;&#125;<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">free_size</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> capacity_ - (k_map_.<span class="hljs-built_in">size</span>() + inf_map_.<span class="hljs-built_in">size</span>()); &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">evict</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (inf_map_.<span class="hljs-built_in">size</span>() != <span class="hljs-number">0</span>) &#123;<br>      inf_map_.<span class="hljs-built_in">erase</span>(inf_que_.<span class="hljs-built_in">front</span>().value_.first);<br>      inf_que_.<span class="hljs-built_in">pop_front</span>();<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    k_map_.<span class="hljs-built_in">erase</span>(k_que_.<span class="hljs-built_in">front</span>().value_.first);<br>    k_que_.<span class="hljs-built_in">pop_front</span>();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (k_map_.<span class="hljs-built_in">contains</span>(key)) &#123;<br>      <span class="hljs-keyword">auto</span> [_, value] = k_map_[key]-&gt;value_;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">put</span>(key, value);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (inf_map_.<span class="hljs-built_in">contains</span>(key)) &#123;<br>      <span class="hljs-keyword">auto</span> [_, value] = inf_map_[key]-&gt;value_;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">put</span>(key, value);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put_k</span><span class="hljs-params">(<span class="hljs-type">const</span> Page &amp;page)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> [key, value] = page.value_;<br>    <span class="hljs-keyword">auto</span> pos = std::<span class="hljs-built_in">upper_bound</span>(k_que_.<span class="hljs-built_in">begin</span>(), k_que_.<span class="hljs-built_in">end</span>(), page,<br>                                [](<span class="hljs-type">const</span> Page &amp;p1, <span class="hljs-type">const</span> Page &amp;p2) &#123;<br>                                  <span class="hljs-keyword">return</span> p1.<span class="hljs-built_in">k_distance</span>() &lt; p2.<span class="hljs-built_in">k_distance</span>();<br>                                &#125;);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">free_size</span>() == <span class="hljs-number">0</span>)<br>      <span class="hljs-built_in">evict</span>();<br>    k_map_[key] = k_que_.<span class="hljs-built_in">insert</span>(pos, page);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put_inf</span><span class="hljs-params">(<span class="hljs-type">const</span> Page &amp;page)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> [key, value] = page.value_;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">free_size</span>() == <span class="hljs-number">0</span>)<br>      <span class="hljs-built_in">evict</span>();<br>    inf_map_[key] = inf_que_.<span class="hljs-built_in">insert</span>(inf_que_.<span class="hljs-built_in">end</span>(), page);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (k_map_.<span class="hljs-built_in">contains</span>(key)) &#123;<br>      <span class="hljs-keyword">auto</span> page = *k_map_[key];<br><br>      k_que_.<span class="hljs-built_in">erase</span>(k_map_[key]);<br>      k_map_.<span class="hljs-built_in">erase</span>(key);<br><br>      page.<span class="hljs-built_in">record</span>(cur_time_++);<br>      <span class="hljs-built_in">put_k</span>(page);<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (inf_map_.<span class="hljs-built_in">contains</span>(key)) &#123;<br>      <span class="hljs-keyword">auto</span> iter = inf_map_[key];<br>      iter-&gt;<span class="hljs-built_in">record</span>(cur_time_++);<br>      <span class="hljs-keyword">if</span> (iter-&gt;<span class="hljs-built_in">is_k</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> page = *iter;<br>        inf_que_.<span class="hljs-built_in">erase</span>(iter);<br>        inf_map_.<span class="hljs-built_in">erase</span>(key);<br>        <span class="hljs-built_in">put_k</span>(page);<br>      &#125;<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;<br>    Page page&#123;key, value, k_&#125;;<br>    page.<span class="hljs-built_in">record</span>(cur_time_++);<br>    <span class="hljs-keyword">if</span> (page.<span class="hljs-built_in">is_k</span>()) <span class="hljs-built_in">put_k</span>(page);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">put_inf</span>(page);<br>    <span class="hljs-keyword">return</span> value;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h3><blockquote><p>LFU（least frequently used (LFU) page-replacement algorithm）。即最不经常使用页置换算法，要求在页置换时置换引用计数最小的页，因为经常使用的页应该有一个较大的引用次数。但是有些页在开始时使用次数很多，但以后就不再使用，这类页将会长时间留在内存中，因此可以将引用计数寄存器定时右移一位，形成指数衰减的平均使用次数。</p></blockquote><h4 id="实现思路-2"><a href="#实现思路-2" class="headerlink" title="实现思路"></a>实现思路</h4><p>每次要替换时，都替换使用次数最少的，如果此时相同，就替换使用最少并且上次使用时间到现在时间最长的。当有多个使用次数相同时，与 LRU 算法一样了。</p><p>容量为 6，按照 4，7，2，4，6，6，6，4，2，3，2，5，6 的顺序访问:</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU15-445/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2/LFU0.png" alt="按照 4，7，2，4，6，6，6，4，2，3，2，5，6 的顺序访问"></p><p>把 计数 与 双端链表映射起来，记录了对应的计数的同时，又能找到上次使用时间的大小关系。</p><p>此时访问 1 ：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU15-445/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2/LFU1.png" alt="访问 1"></p><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU15-445/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2/LFU2.png" alt="访问 1"></p><p>最少使用的次数为 1，但是有 3 个页都是使用了 1 次，这时使用类似 LRU 的思想对着三个页进行判断，7 的上次访问时间到现在是最久的，替换掉 7。</p><p>访问 5 时：</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU15-445/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2/LFU4.png" alt="访问 5"></p><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU15-445/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2/LFU5.png" alt="访问 5"></p><p>这次访问需要 5 所在节点的指针来帮助移动这个节点，通用可以使用哈希映射的方式来实现。</p><p>到此为止，已经使用了两个哈希标了：</p><ul><li>count =&gt; list</li><li>id =&gt; list_ptr</li></ul><p>还有一个问题，怎么找使用最少的次数，哈希表是不具有排序功能的，因此需要额外的帮助来实现。</p><p>可以通过一个变量 <code>n</code> 来记录，当访问一个新的页面时，这个变量为 1 (新的页面 count = 1)。 当 <code>n</code> 映射的列表为空时，要把 <code>n++</code>(最小计数是 +1 的方式增加的)。</p><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p><a href="https://leetcode.cn/problems/lfu-cache/">460. LFU 缓存 - 力扣（LeetCode）</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LFUCache</span> &#123;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> key_;<br>    <span class="hljs-type">int</span> value_;<br>    <span class="hljs-type">int</span> cnt_;<br>    <span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value, <span class="hljs-type">int</span> cnt) : <span class="hljs-built_in">key_</span>(key), <span class="hljs-built_in">value_</span>(value), <span class="hljs-built_in">cnt_</span>(cnt) &#123;&#125;<br>  &#125;;<br>  <span class="hljs-keyword">using</span> list_ptr = std::unique_ptr&lt;std::list&lt;node&gt;&gt;;<br>  <span class="hljs-keyword">using</span> list_iter = std::list&lt;node&gt;::iterator;<br><br><span class="hljs-keyword">private</span>:<br>  std::unordered_map&lt;<span class="hljs-type">int</span>, list_ptr&gt; count_;<br>  std::unordered_map&lt;<span class="hljs-type">int</span>, list_iter&gt; key_value_;<br>  <span class="hljs-type">int</span> lfu_cnt_;<br>  <span class="hljs-type">int</span> capacity_;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">LFUCache</span>(<span class="hljs-type">int</span> capacity) : <span class="hljs-built_in">lfu_cnt_</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">capacity_</span>(capacity) &#123;&#125;<br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (key_value_.<span class="hljs-built_in">count</span>(key) == <span class="hljs-number">0</span> || capacity_ == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">put</span>(key, key_value_[key]-&gt;value_);<br>    <span class="hljs-keyword">return</span> key_value_[key]-&gt;value_;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">int</span> count, list_iter iter)</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span>(count_.<span class="hljs-built_in">count</span>(count) != <span class="hljs-number">0</span>);<br>    count_[count]-&gt;<span class="hljs-built_in">erase</span>(iter);<br>    <span class="hljs-keyword">if</span> (count_[count]-&gt;<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>      count_.<span class="hljs-built_in">erase</span>(count);<br>      <span class="hljs-keyword">if</span> (count == lfu_cnt_)<br>        lfu_cnt_ += <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> count, node value)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (count_.<span class="hljs-built_in">count</span>(count) == <span class="hljs-number">0</span>) &#123;<br>      count_[count] = std::make_unique&lt;std::list&lt;node&gt;&gt;();<br>    &#125;<br>    count_[count]-&gt;<span class="hljs-built_in">push_back</span>(value);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (key_value_.<span class="hljs-built_in">count</span>(key) != <span class="hljs-number">0</span>) &#123;<br>      count = key_value_[key]-&gt;cnt_ + <span class="hljs-number">1</span>;<br>      <span class="hljs-built_in">erase</span>(count - <span class="hljs-number">1</span>, key_value_[key]);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key_value_.<span class="hljs-built_in">size</span>() &gt;= capacity_) &#123;<br>      key_value_.<span class="hljs-built_in">erase</span>(count_[lfu_cnt_]-&gt;<span class="hljs-built_in">begin</span>()-&gt;key_);<br>      <span class="hljs-built_in">erase</span>(lfu_cnt_, count_[lfu_cnt_]-&gt;<span class="hljs-built_in">begin</span>());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (key_value_.<span class="hljs-built_in">count</span>(key) == <span class="hljs-number">0</span>)<br>      lfu_cnt_ = count = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">insert</span>(count, node&#123;key, value, count&#125;);<br>    key_value_[key] = --(count_[count]-&gt;<span class="hljs-built_in">end</span>());<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h2><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU15-445/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2/bufferpoolmanager.png" alt="Buffer Pool Manger"></p><p><code>Page *pages</code> 存放页面的数组</p><p><code>std::unordered_map&lt;page_id_t, frame_id_t&gt; page_table</code> 将页面 id 与页面在数组中的位置映射起来.</p><p><code>std::list&lt;frame_id_t&gt; free_list</code> 数组中还没有页面的下标.</p><p>通过 <code>pages + frame_id_t</code> 的方式来访问 <code>page</code>.</p><p><code>page_table</code> 存储 <code>page_id_t</code> 与 <code>frame_id_t</code> 的映射来帮助 <code>LRU</code> 管理页面替换.</p><p>当要获取的页面在内存中, 通过 <code>DiskManager</code> 读上来, 使用 <code>BufferPoolManager::NewPage</code> 和 替换/刷新页面操作时(要判断是否时 <code>dirty</code>), 要使用 <code>DiskManager::WritePage</code> 将内容写到磁盘.</p><p><code>pages</code> 中被替换出来的页面下标是无序的, 因此通过 <code>free_list</code> 来记录, 有页面从缓冲池中被驱逐, 就把它的下标放到 <code>free_list</code> 中. 当需要向 <code>pages</code> 中放入页面时, 从 <code>free_list</code> 中取出下标即可.</p><p><code>DiskManager</code> 是通过 <code>fstream</code> 来读写磁盘的.</p><h3 id="LRU-的小优化"><a href="#LRU-的小优化" class="headerlink" title="LRU 的小优化"></a>LRU 的小优化</h3><p>使用哈希映射的方法导致, 在频繁的插入和删除操作中带来了性能损失.</p><p>使用哈希是为了起到快速查询的作用, 同样具有 $O(1)$ 的时数组, 通常不选用数组是因为 <code>key</code> 的类型不为数字, 这里的 <code>key</code> 为数字表示, 可以尝试使用数组来优化.</p><p>使用 <code>std::vector&lt;std::list&lt;frame_id_t&gt;::iterator&gt;</code> 来做优化, 删除时只需要赋值为 <code>list&lt;frame_id_t&gt;::end</code> 即可. 这样只有赋值的开销了.</p><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU15-445/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2/usehash.png" alt="使用哈希"></p><p><img src="/images/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU15-445/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2/usearray.png" alt="使用数组"></p><p>剩下的优化应该在锁上了.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://dl.acm.org/doi/epdf/10.1145/170036.170081">The LRU-K page replacement algorithm for database disk buffering - acm</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lab</tag>
      
      <tag>CMU15-445</tag>
      
      <tag>页面置换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RAII 与 智能指针</title>
    <link href="/2023/02/17/RAII%20%E4%B8%8E%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <url>/2023/02/17/RAII%20%E4%B8%8E%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<p>在使用指针时，我们有时会忘记 <code>delete/free</code> 而导致内存泄漏，或者在复杂的逻辑中将指针重复释放等。</p><p>在现代 C++ 中，我们有了很好的方法来解决这些问题。</p><h2 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h2><pre><code class="hljs">RAII，全称资源获取即初始化（Resource Acquisition Is Initialization)</code></pre><p>将指针封装在一个类中，在类的构造函数中为指针分配资源，在类的析构函数中为释放掉资源。</p><p>类在离开它的生命周期后会自动调用析构函数，利用这一点，我们可以不用在担心忘记释放掉资源。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;A()\n&quot;</span>;<br>    &#125;<br>    ~<span class="hljs-built_in">A</span>() &#123;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;~A()\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;&#123;\n&quot;</span>;<br>  &#123;<br>    A a&#123;&#125;;<br>  &#125;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;&#125;\n&quot;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&#123;<br><span class="hljs-function"><span class="hljs-title">A</span><span class="hljs-params">()</span></span><br>~<span class="hljs-built_in">A</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>通过这段代码可以清晰的看到类的构造与析构过程。</p><p>RAII 机制让我们更轻松的使用指针。</p><p>如果我们把指针封装在一个类中，我们需要注意它的拷贝构造与拷贝赋值函数。如果我们把的拷贝仅是拷贝一个指针，<br>那么就会导致有多个对象在离开其作用域时释放指针，这是会造成悬垂引用或重复释放。</p><p>当然，我们可以借助 RAII 机制来封装一个可以拷贝指针的并且保证安全的指针（<code>std::shared_ptr</code>）。</p><p>RAII 就是广义上的智能指针。</p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>我们可以使用 RAII 来帮助我们封装一个更易用且安全的指针。标准库中已经为我们实现了<code>std::unique_ptr</code>, <code>std::shared_ptr</code>, <code>std::weak_ptr</code>。</p><p>这些指针也是线程安全的。</p><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a><code>unique_ptr</code></h3><p>这是一个不可复制的指针。它的拷贝构造函数与拷贝赋值函数都被删除掉了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">unique_ptr</span> &#123;<br>    ...<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">unique_ptr</span>(unique_ptr &amp;other) = <span class="hljs-keyword">delete</span><br>    unique_ptr &amp;<span class="hljs-keyword">operator</span>=(unique_ptr &amp;other) = <span class="hljs-keyword">delete</span><br><br>    <span class="hljs-built_in">unique_ptr</span>(unique_ptr &amp;&amp;other) <span class="hljs-keyword">noexcept</span>;<br>    unique_ptr &amp;<span class="hljs-keyword">operator</span>=(unique_ptr &amp;&amp;other) <span class="hljs-keyword">noexcept</span>;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>但是我们实现了它的移动构造与移动赋值函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; a = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>[]&gt;(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">auto</span> cp = a; <span class="hljs-comment">// 报错, 拷贝构造函数已经被删除。</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; a = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>[]&gt;(<span class="hljs-number">10</span>);<br>a[<span class="hljs-number">1</span>] = a[<span class="hljs-number">2</span>] = a[<span class="hljs-number">3</span>] = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;<br>  cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i==<span class="hljs-number">3</span>];    <span class="hljs-comment">// 正确</span><br>&#125;<br><span class="hljs-keyword">auto</span> cp = std::<span class="hljs-built_in">move</span>(a);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;<br>  cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i==<span class="hljs-number">3</span>];    <span class="hljs-comment">// 报错 段错误</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>unique_ptr</code> 确保了我们只会存在一个对象拥有这个数组的指针的所有权，也只有一个对象可以释放这个指针。</p><p><code>unique_ptr</code> 几乎是零开销的，因此我们可以在保证安全的同时实现高性能。</p><h3 id="shared-ptr-与-weak-ptr"><a href="#shared-ptr-与-weak-ptr" class="headerlink" title="shared_ptr 与 weak_ptr"></a><code>shared_ptr</code> 与 <code>weak_ptr</code></h3><p><code>shared_ptr</code> 是可以被复制的，通过使用计数的方式来确定现在有多少个<code>shared_ptr</code>拥有这个指针的所有权。</p><p>当计数为 0 时才会释放这个指针，这样就避免了重复释放已及提早释放造成的悬垂指针问题。</p><p><strong>但这里还存在一个严重的问题</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    shared_ptr&lt;B&gt; ptr&#123;&#125;;<br>    ~<span class="hljs-built_in">A</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;~A()\n&quot;</span>;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    shared_ptr&lt;A&gt; ptr&#123;&#125;;<br>    ~<span class="hljs-built_in">B</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;~B()\n&quot;</span>;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br>  <span class="hljs-function">shared_ptr&lt;B&gt; <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-keyword">new</span> B())</span></span>;<br>  a-&gt;ptr = b;<br>  b-&gt;ptr = a;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行之后我们没有得到任何结果，<code>a</code> 和 <code>b</code> 并没有被释放。</p><p>A 的内部有指向 B , B 的内部又指向了 A， 对于 A 需要在 B 析构后才能析构， 对于 B 需要在 A 析构后才能析构，这时谁都无法析构，出现了<strong>循环引用的问题</strong>。</p><p>为了解决这个问题，我们引入了 <code>weak_ptr</code> 它可以与 <code>shared_ptr</code> 指向同一个资源，但是不会增加<code>shared_ptr</code> 的计数，并且也不会释放资源。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    weak_ptr&lt;B&gt; ptr&#123;&#125;;<br>    ~<span class="hljs-built_in">A</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;~A()\n&quot;</span>;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    shared_ptr&lt;A&gt; ptr&#123;&#125;;<br>    ~<span class="hljs-built_in">B</span>() &#123;cout &lt;&lt; <span class="hljs-string">&quot;~B()\n&quot;</span>;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br>  <span class="hljs-function">shared_ptr&lt;B&gt; <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-keyword">new</span> B())</span></span>;<br>  a-&gt;ptr = b;<br>  b-&gt;ptr = a;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们将 A 中的 <code>shared_ptr</code> 换成 <code>weak_ptr</code> ，此时两个对象都可以正确释放。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-string">~B()</span><br><span class="hljs-string">~A()</span><br></code></pre></td></tr></table></figure><p>在这段代码中，a 的计数为 2，b 的计数为 1，可以使用 <code>shared_ptr::use_count()</code> 方法来查看计数，</p><p><code>shared_ptr</code> 会造成些许性能损失，但保障了安全。</p><p>如果可以使用智能指针的话，还是尽量使用智能指针。</p>]]></content>
    
    
    <categories>
      
      <category>Cpp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cpp</tag>
      
      <tag>RAII</tag>
      
      <tag>智能指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文档工具 Doxygen</title>
    <link href="/2023/02/10/doxygen%E5%B7%A5%E5%85%B7/"/>
    <url>/2023/02/10/doxygen%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="Doxygen"><a href="#Doxygen" class="headerlink" title="Doxygen"></a>Doxygen</h2><h3 id="生成配置"><a href="#生成配置" class="headerlink" title="生成配置"></a>生成配置</h3><p>使用 <code>doxygen -g</code> 生成默认配置 或者 使用 <code>doxygen -g &lt;config_file&gt;</code> 通过模板来生成配置。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>使用 <code>doxygen &lt;config_file&gt;</code> 来运行，也可以与构建工具 <code>CMake</code> 相结合使用。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>有多种方法可以将注释标记为文档, 具体可以查看<a href="https://doxygen.nl/manual/docblocks.html">官方文档</a></p><p>C++ 风格</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//! ...text...</span><br></code></pre></td></tr></table></figure><p>or</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/// ...text...</span><br></code></pre></td></tr></table></figure><p>常用指令：<br>|指令|解释|<br>|—|—|<br>|\file |档案的批注说明。|<br>|\author|作者的信息|<br>|\brief|用于class 或function的批注中，后面为class 或function的简易说明。|<br>|\param|格式为\param arg_name 参数说明主要用于函式说明中，后面接参数的名字，然后再接关于该参数的说明。|<br>|\return|后面接函数传回值的说明。用于function的批注中。说明该函数的传回值。|<br>|\retval|格式为\retval value 传回值说明.主要用于函式说明中，说明特定传回值的意义。所以后面要先接一个传回值。然后在放该传回值的说明。|</p><p>更多指令参考<a href="https://doxygen.nl/manual/commands.html">官方文档</a></p><h2 id="在-CMake-中使用-Doxygen"><a href="#在-CMake-中使用-Doxygen" class="headerlink" title="在 CMake 中使用 Doxygen"></a>在 CMake 中使用 Doxygen</h2><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">project<br>├── CMakeLists.txt<br>└── docs<br>    ├── Doxyfile.in<br>    └── doxyfile.cmake<br></code></pre></td></tr></table></figure><h3 id="Doxyfile"><a href="#Doxyfile" class="headerlink" title="Doxyfile"></a>Doxyfile</h3><p>使用 <code>doxygen -g</code> 命令可以在当前位置生成一份 <code>Doxyfile</code> 的默认配置。</p><p><a href="https://github.com/mingzi47/ejson"><code>ejson</code></a> 中的 <code>Doxyfile.in</code> （使用了 <code>graphviz</code>）:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"># Doxyfile <span class="hljs-number">1.9</span><span class="hljs-number">.6</span><br># 编码<br>DOXYFILE_ENCODING      = UTF<span class="hljs-number">-8</span><br># 项目名<br>PROJECT_NAME           = <span class="hljs-string">&quot;ejson&quot;</span><br># 项目描述<br>PROJECT_BRIEF          = <span class="hljs-string">&quot;A recursive descent-based JSON interpreter and generator implemented using C++17.&quot;</span><br># 版本号<br>PROJECT_NUMBER         = <span class="hljs-number">0.0</span><span class="hljs-number">.1</span><br>PROJECT_LOGO           = <br># 程序文档输入目录<br>INPUT                  = @PROJECT_SOURCE_DIR@<br># 递归遍历当前子目录<br>RECURSIVE              = YES<br># 排除的文档<br>EXCLUDE                = @PROJECT_SOURCE_DIR@/docs @PROJECT_SOURCE_DIR@/build @PROJECT_SOURCE_DIR@/test<br># 文档输出目录<br>OUTPUT_DIRECTORY       = <span class="hljs-string">&quot;@PROJECT_BINARY_DIR@/doc&quot;</span><br># 是否关注大小写名称，注意，如果开启了，那么所有的名称都将被小写。<br>CASE_SENSE_NAMES       = NO<br># 按字母顺序排序, 否则按文件中的顺序<br>SORT_BRIEF_DOCS        = YES<br># 构造函数和析构函数列在最前面。如果设置为 NO，则构造函数将显示在<br># 由SORT_BRIEF_DOCS和SORT_MEMBER_DOCS定义的相应顺序。<br># 注意：如果SORT_BRIEF_DOCS设置为 NO 此选项将忽略以进行排序简报<br># 成员文档。<br># 注意：如果SORT_MEMBER_DOCS设置为 NO 则忽略此选项进行排序<br>SORT_MEMBERS_CTORS_1ST = YES<br># 将 SHOW_NAMESPACES 标记设置为 NO 以禁用命名空间的生成页面。<br>SHOW_NAMESPACES        = NO<br># 如果 USE_MDFILE_AS_MAINPAGE 标记引用 markdown 文档的名称是输入的一部分，其内容将放置在主页上<br>USE_MDFILE_AS_MAINPAGE = @PROJECT_SOURCE_DIR@/README.md<br># 在最后生成的文档中，把所有的源代码包含在其中<br>SOURCE_BROWSER         = YES<br># 如果EXT_LINKS_IN_WINDOW选项设置为 YES，doxygen 将打开指向通过标签文档在单独窗口中导入的外部符号。<br>EXT_LINKS_IN_WINDOW    = YES<br># INCLUDE_PATH 标签可用于指定一个或多个目录<br>INCLUDE_PATH           = @PROJECT_SOURCE_DIR@/ejsonlib<br># 添加外部文档<br># TAGFILES               = <span class="hljs-string">&quot;@PROJECT_SOURCE_DIR@/etc/cppreference-doxygen-web.tag.xml=https://en.cppreference.com/w/&quot;</span><br># TAGFILES              += <span class="hljs-string">&quot;@PROJECT_SOURCE_DIR@/etc/linux-man-doxygen-web.tag.xml=http://man7.org/linux/man-pages/&quot;</span><br># TAGFILES              += <span class="hljs-string">&quot;@PROJECT_SOURCE_DIR@/etc/rfc-doxygen-web.tag.xml=https://tools.ietf.org/html/&quot;</span><br># 那些没有使用doxygen格式描述的文档（函数或类等）就不显示了 （YES 显示， 如果EXTRACT_ALL被启用，那么这个标志其实是被忽略的。）<br>HIDE_UNDOC_RELATIONS   = NO<br># 当 INLINE_GROUPED_CLASSES 标记设置为 YES、类、结构和联合时,显示在包含它们的组中（例如使用 \ingroup）<br>INLINE_GROUPED_CLASSES = YES<br>INLINE_SIMPLE_STRUCTS  = YES<br>HTML_COLORSTYLE_HUE    = <span class="hljs-number">204</span><br>HTML_COLORSTYLE_SAT    = <span class="hljs-number">120</span><br>HTML_COLORSTYLE_GAMMA  = <span class="hljs-number">60</span><br># HTML_EXTRA_STYLESHEET  = <span class="hljs-string">&quot;@PROJECT_SOURCE_DIR@/docs/style.css&quot;</span><br># 是否生成 LaTex 格式文档<br>GENERATE_LATEX         = NO<br>EXAMPLE_PATH           = <span class="hljs-string">&quot;@PROJECT_SOURCE_DIR@/doctests&quot;</span><br><br># 在程序文档中允许以图例形式显示函数调用关系，前提是你已经安装了 graphviz 软件包<br>HAVE_DOT               = @DOXYGEN_DOT_FOUND@<br>CLASS_GRAPH            = YES<br>TEMPLATE_RELATIONS     = YES<br>DOT_IMAGE_FORMAT       = png<br>INTERACTIVE_SVG        = NO<br>COLLABORATION_GRAPH    = NO<br><br># 提取信息，包含类的私有数据成员和静态成员<br>EXTRACT_ALL            = YES<br>EXTRACT_PRIVATE        = YES<br>EXTRACT_STATIC         = YES<br>EXTRACT_ANON_NSPACES   = YES<br><br><span class="hljs-meta"># do u liek eclips</span><br>GENERATE_ECLIPSEHELP   = NO<br></code></pre></td></tr></table></figure><h3 id="doxygen-cmake"><a href="#doxygen-cmake" class="headerlink" title="doxygen.cmake"></a>doxygen.cmake</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">find_package</span> (Doxygen)<br><span class="hljs-keyword">if</span> (DOXYGEN_FOUND)<br>    <span class="hljs-keyword">if</span> (Doxygen_dot_FOUND)<br>        <span class="hljs-keyword">set</span> (DOXYGEN_DOT_FOUND YES)<br>    <span class="hljs-keyword">else</span> (<span class="hljs-keyword">NOT</span> Doxygen_dot_FOUND)<br>        <span class="hljs-keyword">set</span> (DOXYGEN_DOT_FOUND NO)<br>    <span class="hljs-keyword">endif</span> (Doxygen_dot_FOUND)<br>    <span class="hljs-keyword">configure_file</span> (<span class="hljs-string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/docs/Doxyfile.in&quot;</span> <span class="hljs-string">&quot;$&#123;PROJECT_BINARY_DIR&#125;/Doxyfile&quot;</span> @ONLY)<br>    <span class="hljs-keyword">add_custom_target</span> (doc <span class="hljs-string">&quot;$&#123;DOXYGEN_EXECUTABLE&#125;&quot;</span> <span class="hljs-string">&quot;$&#123;PROJECT_BINARY_DIR&#125;/Doxyfile&quot;</span><br>                           WORKING_DIRECTORY <span class="hljs-string">&quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span><br>                           COMMENT <span class="hljs-string">&quot;Generate docs using Doxygen&quot;</span> VERBATIM)<br><span class="hljs-keyword">endif</span> ()<br></code></pre></td></tr></table></figure><p>在更目录的 <code>CMakeLists.txt</code> 中 使用 <code>include(docs/doxygen.cmake)</code> 来引入。</p><p>在 <code>build</code> 文件夹下使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">cmake ..</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make doc</span><br></code></pre></td></tr></table></figure><p>文档生成在 <code>build/doc</code> 目录下。</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>Doxygen</tag>
      
      <tag>CMake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144 Lab4 : 组装模块</title>
    <link href="/2023/01/26/CS144%20Lab4/"/>
    <url>/2023/01/26/CS144%20Lab4/</url>
    
    <content type="html"><![CDATA[<h2 id="整体设计"><a href="#整体设计" class="headerlink" title="整体设计"></a>整体设计</h2><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CS144/Lab4/%E5%AE%9E%E9%AA%8C%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1.png" alt="实验整体设计"></p><h2 id="TCP-FSM"><a href="#TCP-FSM" class="headerlink" title="TCP FSM"></a>TCP FSM</h2><h3 id="接收数据："><a href="#接收数据：" class="headerlink" title="接收数据："></a><strong>接收数据</strong>：</h3><ul><li>如果接收到了带有 <code>RST</code> 标志的段，就要立即进行 <code>unclean_shutdown</code></li><li>如果接收到的段没有 <code>RST</code> 标志，将有 <code>TCPReceiver</code> 来处理这个段的 <code>SYN</code>, <code>payload</code>, <code>FIN</code> 和 <code>seqno</code> 。</li><li>若果这个段的 <code>seqno</code> 是无效的，或者 <code>TCPReceiver</code> 接收这个段失败时，要发送一个空的段给对方</li></ul><h3 id="发送数据："><a href="#发送数据：" class="headerlink" title="发送数据："></a><strong>发送数据</strong>：</h3><ul><li><code>TCPSender</code> 将段发送到自己的队列时，<code>TCPConnection</code> 就要从 <code>TCPSender</code> 中取出来放到自己的队列中，在这个过程中如果 <code>TCPReceiver</code> 的 <code>ackno</code> 为有效值的话，就要给这些段加上 <code>ACK</code> 标记，自己的<code>ackno</code> 以及 <code>window size</code>。</li><li><code>TCPConnection</code> 通过 <code>tick</code> 函数获得时间，我们要将时间交给 <code>TCPSender</code> 的 <code>tick</code> 函数，让它来进行重传操作。</li><li>重传的次数超过 <code>TCPConfig::MAX_RETX_ATTMPTS</code> 的话就要发送一个 <code>RST</code> 的段。</li><li>如果 <code>TCPConnection</code> 的 <code>active</code> 为真，这时 <code>TCPConnection</code> 析构了，就要立即发送一个 <code>RST</code> 段。</li></ul><h3 id="unclean-shutdown-："><a href="#unclean-shutdown-：" class="headerlink" title="**unclean_shutdown**："></a>**<code>unclean_shutdown</code>**：</h3><ul><li>收到 <code>RST</code> 标志的段，就是 <code>unclear_shutdown</code>.</li></ul><h3 id="clean-shutdown-："><a href="#clean-shutdown-：" class="headerlink" title="**clean_shutdown**："></a>**<code>clean_shutdown</code>**：</h3><p>完成 4 次挥手。</p><ul><li><p>先收到 <code>FIN</code> 的一方，在最后发送完不需要进行等待。</p></li><li><p>先发送 <code>FIN</code> 的一方，最后发送 <code>ACK</code> 后需要等待一定时间。</p></li><li><p>先收到 <code>FIN</code> 的一方，在收到对方对自己 发送的 <code>FIN</code> 的确认 <code>ACK</code> 后，就立刻关闭了，不在发送其他数据。</p></li><li><p>先发送 <code>FIN</code> 的一方通过等待 10 $\times$ 初始超时时间限制 时间来确认对方收到了自己的 <code>ACK</code> , 在这段时间里没有重传就结束。 </p></li></ul><p>感觉代码有些难写，多次测试不能完全保证每次测试都通过。</p><h3 id="TCP-有限状态机"><a href="#TCP-有限状态机" class="headerlink" title="TCP 有限状态机"></a><strong>TCP 有限状态机</strong></h3><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CS144/Lab4/TCP-FSM.png" alt="TCP FSM"></p><h3 id="Receiver"><a href="#Receiver" class="headerlink" title="Receiver"></a><strong>Receiver</strong></h3><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CS144/Lab4/receiver.png" alt="receiver"></p><h3 id="Sender"><a href="#Sender" class="headerlink" title="Sender"></a><strong>Sender</strong></h3><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CS144/Lab4/sender.png" alt="sender"></p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>使用 <code>gprof</code> 工具分析性能。</p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CS144/Lab4/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.png" alt="优化前"></p><p>可以看到 <code>ByteStream::write</code> , <code>ByteStream::peek_output</code> 和 <code>ByteStream::pop_output</code> 占用了快 90% 的时间，这主要是方法内部实现使用的深拷贝。</p><p>实验在 <code>util</code> 提供了 <code>Buffer</code> , <code>BufferList</code> 和 <code>BufferListView</code> 这样的类。</p><p><code>Buffer</code> 的 <code>remove_prefix</code> 方法是常数级别的删除前 <code>n</code> 个字符。<code>Buffer</code>存放的是智能指针，及 <code>size_t</code> 类型的标记来表示字符的开始位置，删除前 <code>n</code> 个字符只需要变动这个标记即可，智能指针指向的内存会随着 <code>Buffer</code> 的析构而释放，在获得性能的同时保持安全。</p><p>使用 <code>BufferList</code> 重写 <code>ByteStream</code> 后的性能分析。 </p><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CS144/Lab4/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.png" alt="优化后"></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lab</tag>
      
      <tag>CS144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144 Lab3 : TCPSender</title>
    <link href="/2023/01/16/CS144%20Lab3/"/>
    <url>/2023/01/16/CS144%20Lab3/</url>
    
    <content type="html"><![CDATA[<p>实现 TCP 协议中的发送器 <code>TCPSender</code> 。</p><p>TCP 通过累积确认的方式来标记哪些段不需要跟踪了，发送方收到了一个 <code>ackno</code> ，表示接收方已经接收了 <code>ackno</code> 之前的所有数据。可以使用 <code>queue</code> 来跟踪没被确认的，一旦确认了就出队，同时也方便重传数据。</p><p>累积确认类似与 GBN（go back N）协议。在接收方 GBN 机制选择将待确认的全部丢弃了，在这次实验中 (Lab2), 选择了缓存这些待确认的，这类似与 SR（Selective Repeat）协议。</p><h2 id="定时器机制"><a href="#定时器机制" class="headerlink" title="定时器机制"></a><strong>定时器机制</strong></h2><ul><li>一段报文被发送时，定时器没有开启就开启，开启了就什么都不做。</li><li>定时器超时，这是就要重传还没有被确认的序号最小的段，同时，超时时间限制要扩大两倍，定时器重新计时。</li><li>收到一个合法的 <code>ackno</code> 时（严格大于已经被确认的最大的序号），定时器的超时时间限制回到初始值，并且不再跟踪已经确认的段，如果还有跟踪的段，开启定时器。</li></ul><p><img src="/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CS144/Lab3/%E5%AE%9A%E6%97%B6%E5%99%A8%E5%90%AF%E5%8A%A8%E6%97%B6%E6%9C%BA.png" alt="定时器启动时机"></p><p><strong>如果一个段的一部分被确认了，这个段仍然被认为是没有被确认的</strong>，事实上，TCP的实现上可以认为它是被确认的。作为实验，这里简化了操作。</p><p>需要注意的是，第一次握手时发送的段只包含 <code>SYN</code> 不包含其他数据。 </p><p>在 Lab3 中 我们有一个发送空段的函数 <code>send_empty_segment</code> 可以用来探测接收方容量窗口大小，但是在 Lab2 中，并没处理接收一个空段会怎样。</p><h3 id="tcp-receiver-cc"><a href="#tcp-receiver-cc" class="headerlink" title="tcp_receiver.cc"></a><code>tcp_receiver.cc</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TCPReceiver::segment_received</span><span class="hljs-params">(<span class="hljs-type">const</span> TCPSegment &amp;seg)</span> </span>&#123;<br><span class="hljs-comment">// ....</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> abs_seqno = <span class="hljs-built_in">unwrap</span>(seg.<span class="hljs-built_in">header</span>().seqno, _isn.<span class="hljs-built_in">value</span>(), _pos);<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> index = abs_seqno + (issyn ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 在 Lab3 之后，了解到可能发送一个空的 TCPSegment 用来侦测</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> received_empty_segment = abs_seqno == _pos &amp;&amp; seg.<span class="hljs-built_in">length_in_sequence_space</span>() == <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (received_empty_segment) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// ....</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="tcp-sender-hh"><a href="#tcp-sender-hh" class="headerlink" title="tcp_sender.hh"></a><code>tcp_sender.hh</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TCPSender</span> &#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// ....</span><br>    <span class="hljs-type">uint64_t</span> _recv_ackno&#123;<span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-type">bool</span> _syn_flag&#123;<span class="hljs-literal">false</span>&#125;;<br>    <span class="hljs-type">bool</span> _fin_flag&#123;<span class="hljs-literal">false</span>&#125;;<br><br>    <span class="hljs-type">uint64_t</span> _windows_size&#123;<span class="hljs-number">0</span>&#125;;<br>    std::queue&lt;TCPSegment&gt; _segments_outstanding&#123;&#125;;<br><br>    <span class="hljs-type">uint64_t</span> _timer&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">uint64_t</span> _timeout;<br>    <span class="hljs-type">bool</span> _time_running&#123;<span class="hljs-literal">false</span>&#125;;<br><br>    <span class="hljs-type">uint64_t</span> _byte_in_flight&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">uint64_t</span> _consecutive_retransmissions&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-comment">// ....</span><br></code></pre></td></tr></table></figure><h3 id="tcp-sender-cc"><a href="#tcp-sender-cc" class="headerlink" title="tcp_sender.cc"></a><code>tcp_sender.cc</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TCPSender::<span class="hljs-built_in">TCPSender</span>(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> capacity, <span class="hljs-type">const</span> <span class="hljs-type">uint16_t</span> retx_timeout, <span class="hljs-type">const</span> std::optional&lt;WrappingInt32&gt; fixed_isn)<br>    : _isn(fixed_isn.<span class="hljs-built_in">value_or</span>(WrappingInt32&#123;<span class="hljs-built_in">random_device</span>()()&#125;))<br>    , _initial_retransmission_timeout&#123;retx_timeout&#125;<br>    , _stream(capacity)<br>    , _timeout&#123;retx_timeout&#125; &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">TCPSender::bytes_in_flight</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _byte_in_flight; &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPSender::fill_window</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!_syn_flag) &#123;<br>        TCPSegment seg&#123;&#125;;<br>        seg.<span class="hljs-built_in">header</span>().syn = <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">send_segment</span>(seg);<br>        _syn_flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> win_size = _windows_size ? _windows_size : <span class="hljs-number">1</span>;<br>    <span class="hljs-type">size_t</span> remain_win&#123;&#125;;<br>    <span class="hljs-keyword">while</span> ((remain_win = win_size - _next_seqno + _recv_ackno) &gt; <span class="hljs-number">0</span> &amp;&amp; !_fin_flag) &#123;<br>        TCPSegment seg&#123;&#125;;<br>        <span class="hljs-type">const</span> <span class="hljs-type">uint16_t</span> length = std::<span class="hljs-built_in">min</span>(TCPConfig::MAX_PAYLOAD_SIZE, remain_win);<br>        std::string data = _stream.<span class="hljs-built_in">read</span>(length);<br>        seg.<span class="hljs-built_in">payload</span>() = Buffer&#123;std::<span class="hljs-built_in">move</span>(data)&#125;;<br><br>        <span class="hljs-type">const</span> <span class="hljs-type">bool</span> eof = _stream.<span class="hljs-built_in">eof</span>() &amp;&amp; seg.<span class="hljs-built_in">length_in_sequence_space</span>() &lt; win_size;<br>        <span class="hljs-keyword">if</span> (eof) &#123;<br>            seg.<span class="hljs-built_in">header</span>().fin = <span class="hljs-literal">true</span>;<br>            _fin_flag = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-type">const</span> <span class="hljs-type">bool</span> empty_segment = seg.<span class="hljs-built_in">length_in_sequence_space</span>() == <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (empty_segment) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">send_segment</span>(seg);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TCPSender::ack_received</span><span class="hljs-params">(<span class="hljs-type">const</span> WrappingInt32 ackno, <span class="hljs-type">const</span> <span class="hljs-type">uint16_t</span> window_size)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> abs_seqno = <span class="hljs-built_in">unwrap</span>(ackno, _isn, _recv_ackno);<br><br>    <span class="hljs-keyword">if</span> (abs_seqno &gt; _next_seqno) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    _windows_size = window_size;<br><br>    <span class="hljs-keyword">if</span> (abs_seqno &lt;= _recv_ackno) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    _recv_ackno = abs_seqno;<br><br>    _timeout = _initial_retransmission_timeout;<br>    _consecutive_retransmissions = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (!_segments_outstanding.<span class="hljs-built_in">empty</span>()) &#123;<br>        TCPSegment&amp; seg = _segments_outstanding.<span class="hljs-built_in">front</span>();<br>        <span class="hljs-type">const</span> <span class="hljs-type">bool</span> ac_segments = <span class="hljs-built_in">unwrap</span>(seg.<span class="hljs-built_in">header</span>().seqno, _isn, _recv_ackno) <br>            + seg.<span class="hljs-built_in">length_in_sequence_space</span>() &lt;= abs_seqno;<br>        <span class="hljs-keyword">if</span> (ac_segments) &#123;<br>            _byte_in_flight -= seg.<span class="hljs-built_in">length_in_sequence_space</span>();<br>            _segments_outstanding.<span class="hljs-built_in">pop</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">fill_window</span>();<br>    <span class="hljs-comment">// 事件 ： 如果当前有未被确认的报文段，开始定时器</span><br>    <span class="hljs-keyword">if</span> (!_segments_outstanding.<span class="hljs-built_in">empty</span>()) &#123;<br>        _time_running = <span class="hljs-literal">true</span>;<br>        _timer = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPSender::tick</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> ms_since_last_tick)</span> </span>&#123;<br>    _timer += ms_since_last_tick; <span class="hljs-comment">// ms_since_last_tick 过去了多长时间</span><br><br>    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> timeout_resend = _timer &gt;= _timeout &amp;&amp; !_segments_outstanding.<span class="hljs-built_in">empty</span>();<br><br>    <span class="hljs-comment">// 事件：定时器超时</span><br>    <span class="hljs-keyword">if</span> (timeout_resend) &#123;<br>        _segments_out.<span class="hljs-built_in">push</span>(_segments_outstanding.<span class="hljs-built_in">front</span>());<br>        _consecutive_retransmissions++;<br>        _timeout *= <span class="hljs-number">2</span>;<br>        _time_running = <span class="hljs-literal">true</span>;<br>        _timer = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (_segments_outstanding.<span class="hljs-built_in">empty</span>()) &#123;<br>        _time_running = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">TCPSender::consecutive_retransmissions</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _consecutive_retransmissions; &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPSender::send_empty_segment</span><span class="hljs-params">()</span> </span>&#123;<br>    TCPSegment res&#123;&#125;;<br>    res.<span class="hljs-built_in">header</span>().seqno = <span class="hljs-built_in">wrap</span>(_next_seqno, _isn);<br>    _segments_out.<span class="hljs-built_in">push</span>(res);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPSender::send_segment</span><span class="hljs-params">(TCPSegment&amp; seg)</span> </span>&#123;<br>    seg.<span class="hljs-built_in">header</span>().seqno = <span class="hljs-built_in">wrap</span>(_next_seqno, _isn);<br>    _next_seqno += seg.<span class="hljs-built_in">length_in_sequence_space</span>();<br>    _byte_in_flight += seg.<span class="hljs-built_in">length_in_sequence_space</span>();<br>    _segments_out.<span class="hljs-built_in">push</span>(seg);<br>    _segments_outstanding.<span class="hljs-built_in">push</span>(seg);<br>    <span class="hljs-comment">// 事件： 从上面的应用程序接收到数据，定时器没有启动</span><br>    <span class="hljs-keyword">if</span> (!_time_running) &#123;<br>        _time_running = <span class="hljs-literal">true</span>;<br>        _timer = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lab</tag>
      
      <tag>CS144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144 Lab2 : TCPReceiver</title>
    <link href="/2023/01/09/CS144%20Lab2/"/>
    <url>/2023/01/09/CS144%20Lab2/</url>
    
    <content type="html"><![CDATA[<p>这次实验的目标为实现一个 TCP协议 的接收器。</p><h2 id="Sequence-Numbers"><a href="#Sequence-Numbers" class="headerlink" title="Sequence Numbers"></a>Sequence Numbers</h2><table><thead><tr><th>Sequence Numbers</th><th>Absolute Sequence Numbers</th><th>Stream Indices</th></tr></thead><tbody><tr><td>Start at the ISN</td><td>Start at 0</td><td>Start at 0</td></tr><tr><td>Include SYN/FIN</td><td>Include SYN/FIN</td><td>Omit SYN/FIN</td></tr><tr><td>32 bits, wrapping</td><td>64 bits, non-wrapping</td><td>64 bits, non-wrapping</td></tr><tr><td>“seqno”</td><td>“absolute seqno”</td><td>“stream index”</td></tr></tbody></table><p>我们要实现的就是 “seqno” 与 “absolute seqno” 之间的互相转换。</p><p>“seqno” =&gt; “absolute seqno” </p><p>“seqno” 向 “absolute seqno” 的转换可能并不唯一， 因此我们找到离 <code>checkpoint</code> 最近的那一个。</p><p>“seqno” 一定是在 $[max(checkpoint - (1 &lt;&lt; 31), 0), checkpoint + (1 &lt;&lt;31)]$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">WrappingInt32 <span class="hljs-title">wrap</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> n, WrappingInt32 isn)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> max_seqno = <span class="hljs-type">uint64_t</span>&#123;<span class="hljs-number">1</span>&#125; &lt;&lt; <span class="hljs-number">32</span>;<br>    <span class="hljs-keyword">if</span> (n &lt; max_seqno - isn.<span class="hljs-built_in">raw_value</span>()) &#123;<br>        <span class="hljs-keyword">return</span> WrappingInt32&#123;isn + n&#125;;<br>    &#125;<br>    n -= (max_seqno - isn.<span class="hljs-built_in">raw_value</span>());<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> res = n % max_seqno;<br>    <span class="hljs-keyword">return</span> WrappingInt32&#123;res&#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">unwrap</span><span class="hljs-params">(WrappingInt32 n, WrappingInt32 isn, <span class="hljs-type">uint64_t</span> checkpoint)</span> </span>&#123;<br>    <span class="hljs-comment">// DUMMY_CODE(n, isn, checkpoint);</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> max_seqno = <span class="hljs-type">uint64_t</span>&#123;<span class="hljs-number">1</span>&#125; &lt;&lt; <span class="hljs-number">32</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int32_t</span> count = (checkpoint &lt; max_seqno ? <span class="hljs-number">0</span> : checkpoint / max_seqno);<br>    <span class="hljs-type">uint64_t</span> res&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">if</span> (n.<span class="hljs-built_in">raw_value</span>() &gt;= isn.<span class="hljs-built_in">raw_value</span>()) &#123;<br>        res = n.<span class="hljs-built_in">raw_value</span>() - isn.<span class="hljs-built_in">raw_value</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        res = max_seqno - isn.<span class="hljs-built_in">raw_value</span>() + n.<span class="hljs-built_in">raw_value</span>();<br>    &#125;<br>    res += (max_seqno * count);<br>    <span class="hljs-keyword">if</span> (res &gt; checkpoint &amp;&amp; res &gt;= max_seqno) &#123;<br>        <span class="hljs-keyword">if</span> (res - checkpoint &gt; max_seqno / <span class="hljs-number">2</span>) res -= max_seqno;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res &lt; checkpoint) &#123;<br>        <span class="hljs-keyword">if</span> (checkpoint - res &gt; max_seqno / <span class="hljs-number">2</span>) res += max_seqno;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Implementing-the-TCP-receiver"><a href="#Implementing-the-TCP-receiver" class="headerlink" title="Implementing the TCP receiver"></a>Implementing the TCP receiver</h2><p>需要注意：</p><ul><li><p>在接收一个 SYN 前，任何数据段都会被拒绝</p></li><li><p>接收一个 SYN 后，不再接收含有 SYN 的 <code>TCPSegment</code></p></li><li><p>接收一个 FIN 后，不再接收含有 FIN 的 <code>TCPSegment</code></p></li><li><p><code>TCPSegment</code> 的数据与接收窗口没有交集就会被拒绝</p></li><li><p>SYN 和 FIN 都会占用一个序号</p></li></ul><p><code>stream_reassembler.hh</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamReassembler</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">head_index</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _head_index; &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">input_ended</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _output.<span class="hljs-built_in">input_ended</span>(); &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>tcp_receiver.hh</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TCPReceiver</span> &#123;<br>    <span class="hljs-comment">//! Our data structure for re-assembling bytes.</span><br>    StreamReassembler _reassembler;<br><br>    <span class="hljs-comment">//! The maximum number of bytes we&#x27;ll store.</span><br>    <span class="hljs-type">size_t</span> _capacity;<br><br>    <span class="hljs-type">uint64_t</span> _pos&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">bool</span> _fin&#123;<span class="hljs-literal">false</span>&#125;;<br>    std::optional&lt;WrappingInt32&gt; _isn&#123;std::<span class="hljs-literal">nullopt</span>&#125;;<br>    <span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p><code>tcp_receiver.cc</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TCPReceiver::segment_received</span><span class="hljs-params">(<span class="hljs-type">const</span> TCPSegment &amp;seg)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> issyn = seg.<span class="hljs-built_in">header</span>().syn;<br>    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> isfin = seg.<span class="hljs-built_in">header</span>().fin;<br>    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> refuse = (_isn != <span class="hljs-literal">nullopt</span> &amp;&amp; issyn) || (_fin &amp;&amp; isfin) || (_isn == <span class="hljs-literal">nullopt</span> &amp;&amp; !issyn);<br><br>    <span class="hljs-keyword">if</span> (refuse) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (issyn) &#123;<br>        _isn = seg.<span class="hljs-built_in">header</span>().seqno;<br>        _pos = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (isfin) _fin = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> abs_seqno = <span class="hljs-built_in">unwrap</span>(seg.<span class="hljs-built_in">header</span>().seqno, _isn.<span class="hljs-built_in">value</span>(), _pos);<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> index = abs_seqno + (issyn ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">bool</span> inbound = abs_seqno + seg.<span class="hljs-built_in">length_in_sequence_space</span>() &lt;= _pos || abs_seqno &gt;= _pos + <span class="hljs-built_in">window_size</span>();<br><br>    <span class="hljs-keyword">if</span> (!issyn &amp;&amp; !isfin &amp;&amp; inbound) <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// SYN 不被算在 “Stream index” 中，因此index - 1。</span><br>    _reassembler.<span class="hljs-built_in">push_substring</span>(seg.<span class="hljs-built_in">payload</span>().<span class="hljs-built_in">copy</span>(), index - <span class="hljs-number">1</span>, isfin); <br>    _pos = _reassembler.<span class="hljs-built_in">head_pos</span>() + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// FIN 会占一个序号</span><br>    <span class="hljs-keyword">if</span> (_reassembler.<span class="hljs-built_in">input_ended</span>()) &#123;  <br>        _pos++;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function">optional&lt;WrappingInt32&gt; <span class="hljs-title">TCPReceiver::ackno</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> _pos == <span class="hljs-number">0</span> ? std::<span class="hljs-literal">nullopt</span> : optional&lt;WrappingInt32&gt;&#123;<span class="hljs-built_in">wrap</span>(_pos, _isn.<span class="hljs-built_in">value</span>())&#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">TCPReceiver::window_size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _reassembler.<span class="hljs-built_in">stream_out</span>().<span class="hljs-built_in">remaining_capacity</span>(); &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lab</tag>
      
      <tag>CS144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144 Lab1 : 流重组器</title>
    <link href="/2023/01/08/CS144%20Lab1/"/>
    <url>/2023/01/08/CS144%20Lab1/</url>
    
    <content type="html"><![CDATA[<h2 id="Putting-substrings-in-sequence"><a href="#Putting-substrings-in-sequence" class="headerlink" title="Putting substrings in sequence"></a>Putting substrings in sequence</h2><p>实现一个流重组器。可以将带有索引的流碎片按照顺序重组。这些流碎片是可以重复的部分，但是不会有冲突的部分。这些流碎片将通过 Lab0 中 实现的 <code>ByteStream</code> 来将其有序的传输出去。</p><p>需要注意的是：</p><ul><li><p>eof 不一定是最后一个片段被传入的</p></li><li><p>如果该字节流前面的字节没有被写入 <code>ByteStream</code>, 该字节流不能被写入 <code>ByteStream</code>， 一旦可以写入，就要立即写入。</p></li><li><p>容量限制，不限制的话，流重组器会越来越大。</p></li><li><p>会存在为空的带 <code>EOF</code> 的字符串</p></li></ul><p>最初，使用 <code>std::map&lt;size_t, std::string&gt;</code> 来实现， <code>key</code> 中存放的是 <code>index + data.size()</code>, 这样可以非常方便的使用 <code>lower_bound</code> 来确认一个新的片段要与 <code>map</code> 中的哪些段合并。写完测试也通过了(当时运气好)，但是第二遍测试就挂掉了，由于代码写的太乱，就用其他方法重写了。</p><p>把操作分为三部</p><ul><li><p>剪切掉已经写入 <code>_output</code> 的部分。</p></li><li><p>与 <code>map</code> 中的其他片段合并。</p></li><li><p>写入 <code>_output</code></p></li></ul><p>关于片段合并，我使用一个结构体 <code>SubString</code> 来存储片段， 同时为这个结构体设置一个 <code>merge</code> 方法， 让它可以把其他的结构体合并到自己身上， 返回值为 ：</p><ul><li><p>如果不能合并， 返回 <code>std::nullopt</code></p></li><li><p>如果可以合并， 返回这两个片段中有多少字段重复的</p></li></ul><p>通过 <code>lower_bound</code> 来找可以合并的片段即可。</p><p><code>stream_reassembler.hh</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SubString</span> &#123;<br>    std::string _data&#123;&#125;;<br>    <span class="hljs-type">size_t</span> _begin&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">size_t</span> _size&#123;<span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-built_in">SubString</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">SubString</span>(<span class="hljs-type">const</span> std::string &amp;data, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> begin, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> size)<br>      : _data&#123;data&#125;, _begin&#123;begin&#125;, _size&#123;size&#125; &#123;&#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> SubString &amp;rhs) <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> _begin &lt; rhs._begin; &#125;<br><br>    <span class="hljs-function">std::optional&lt;<span class="hljs-type">size_t</span>&gt; <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">const</span> SubString &amp;other)</span> </span>&#123;<br>        SubString lhs&#123;&#125;, rhs&#123;&#125;;<br>        <span class="hljs-keyword">if</span> (_begin &gt; other._begin) &#123;<br>            lhs = other;<br>            rhs = *<span class="hljs-keyword">this</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            lhs = *<span class="hljs-keyword">this</span>;<br>            rhs = other;<br>        &#125;<br>        <span class="hljs-comment">// can&#x27;t merge</span><br>        <span class="hljs-keyword">if</span> (lhs._begin + lhs._size &lt; rhs._begin) <span class="hljs-keyword">return</span> std::<span class="hljs-literal">nullopt</span>; <br>        <span class="hljs-comment">// \in</span><br>        <span class="hljs-keyword">if</span> (lhs._begin + lhs._size &gt;= rhs._begin + rhs._size) &#123;<br>          *<span class="hljs-keyword">this</span> = lhs;<br>          <span class="hljs-keyword">return</span> rhs._size;<br>        &#125;<br>        <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> res = lhs._begin + lhs._size - rhs._begin;<br>        lhs._data += rhs._data.<span class="hljs-built_in">substr</span>((lhs._begin + lhs._size) - rhs._begin);<br>        lhs._size = lhs._data.<span class="hljs-built_in">size</span>();<br>        *<span class="hljs-keyword">this</span> = lhs;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//! \brief A class that assembles a series of excerpts from a byte stream (possibly out of order,</span><br><span class="hljs-comment">//! possibly overlapping) into an in-order byte stream.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamReassembler</span> &#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// Your code here -- add private members as necessary.</span><br>    std::set&lt;SubString&gt; _buffer&#123;&#125;;<br>    <span class="hljs-type">size_t</span> _unassembled_bytes&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">size_t</span> _head_pos&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">bool</span> _is_eof&#123;<span class="hljs-literal">false</span>&#125;;<br>    ByteStream _output;  <span class="hljs-comment">//!&lt; The reassembled in-order byte stream</span><br>    <span class="hljs-type">size_t</span> _capacity;    <span class="hljs-comment">//!&lt; The maximum number of bytes</span><br><br>    <span class="hljs-function">SubString <span class="hljs-title">cut_substring</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;data, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> index)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_substring</span><span class="hljs-params">(SubString &amp;ssd)</span></span>;<br>    <span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p><code>stream_reassembler.cc</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StreamReassembler::push_substring</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;data, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> index, <span class="hljs-type">const</span> <span class="hljs-type">bool</span> eof)</span> </span>&#123;<br>    <span class="hljs-comment">// DUMMY_CODE(data, index, eof);</span><br>    <span class="hljs-keyword">if</span> (index &gt;= _head_pos + _capacity) <span class="hljs-keyword">return</span>;<br><br>    SubString ssd = <span class="hljs-built_in">cut_substring</span>(data, index);<br>    <span class="hljs-built_in">merge_substring</span>(ssd);<br><br>    <span class="hljs-keyword">while</span> (_unassembled_bytes &gt; <span class="hljs-number">0</span> &amp;&amp; _output.<span class="hljs-built_in">remaining_capacity</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">auto</span> iter = _buffer.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">if</span> (iter-&gt;_begin != _head_pos) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> push_len = _output.<span class="hljs-built_in">write</span>(iter-&gt;_data);<br>        _unassembled_bytes -= push_len;<br>        _head_pos += push_len;<br>        <span class="hljs-keyword">if</span> (iter-&gt;_size == push_len) &#123;<br>            _buffer.<span class="hljs-built_in">erase</span>(iter);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            SubString unass&#123;std::string&#123;&#125;.<span class="hljs-built_in">assign</span>(iter-&gt;_data.<span class="hljs-built_in">begin</span>() + _head_pos, iter-&gt;_data.<span class="hljs-built_in">end</span>())<br>            ,_head_pos, iter-&gt;_size - push_len&#125;;<br>            _buffer.<span class="hljs-built_in">erase</span>(iter);<br>            _buffer.<span class="hljs-built_in">insert</span>(unass);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (index + data.<span class="hljs-built_in">length</span>() &lt;= _head_pos + _capacity &amp;&amp; eof) &#123;<br>        _is_eof |= eof;<br>    &#125; <br>    <span class="hljs-keyword">if</span> (_unassembled_bytes == <span class="hljs-number">0</span> &amp;&amp; _is_eof) &#123;<br>        _output.<span class="hljs-built_in">end_input</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function">SubString <span class="hljs-title">StreamReassembler::cut_substring</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;data, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> index)</span> </span>&#123;<br>    <span class="hljs-comment">// \in</span><br>    SubString res&#123;&#125;;<br>    <span class="hljs-keyword">if</span> (index + data.<span class="hljs-built_in">size</span>() &lt;= _head_pos) <span class="hljs-keyword">return</span> res;<br>    <span class="hljs-comment">// </span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index &lt; _head_pos) &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> len = _head_pos - index;<br>        res._begin = _head_pos;<br>        res._data.<span class="hljs-built_in">assign</span>(data.<span class="hljs-built_in">begin</span>() + len, data.<span class="hljs-built_in">end</span>());<br>        res._size = res._data.<span class="hljs-built_in">size</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        res._begin = index;<br>        res._data = data;<br>        res._size = data.<span class="hljs-built_in">size</span>();<br>    &#125;<br>    _unassembled_bytes += res._size;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StreamReassembler::merge_substring</span><span class="hljs-params">(SubString &amp;ssd)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (ssd._size == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>; <br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">// next</span><br>        <span class="hljs-keyword">auto</span> iter = _buffer.<span class="hljs-built_in">lower_bound</span>(ssd);<br>        std::optional&lt;<span class="hljs-type">size_t</span>&gt; res&#123;&#125;;<br>        <span class="hljs-keyword">while</span> (iter != _buffer.<span class="hljs-built_in">end</span>() &amp;&amp; (res = ssd.<span class="hljs-built_in">merge</span>(*iter)) != std::<span class="hljs-literal">nullopt</span>) &#123;<br>            _unassembled_bytes -= res.<span class="hljs-built_in">value</span>();<br>            _buffer.<span class="hljs-built_in">erase</span>(iter);<br>            iter = _buffer.<span class="hljs-built_in">lower_bound</span>(ssd);<br>        &#125;<br>        <span class="hljs-comment">// pre</span><br>        <span class="hljs-keyword">if</span> (iter == _buffer.<span class="hljs-built_in">begin</span>()) <span class="hljs-keyword">break</span>;<br>        iter--;<br><br>        <span class="hljs-keyword">while</span> (iter != _buffer.<span class="hljs-built_in">end</span>() &amp;&amp; (res = ssd.<span class="hljs-built_in">merge</span>(*iter)) != std::<span class="hljs-literal">nullopt</span>) &#123;<br>            _unassembled_bytes -=  res.<span class="hljs-built_in">value</span>();<br>            _buffer.<span class="hljs-built_in">erase</span>(iter);<br>            iter = _buffer.<span class="hljs-built_in">lower_bound</span>(ssd);<br>            <span class="hljs-keyword">if</span> (iter == _buffer.<span class="hljs-built_in">begin</span>()) <span class="hljs-keyword">break</span>;<br>            iter--;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span>(<span class="hljs-literal">false</span>);<br>    _buffer.<span class="hljs-built_in">insert</span>(ssd);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">StreamReassembler::unassembled_bytes</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _unassembled_bytes; &#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">StreamReassembler::empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _unassembled_bytes == <span class="hljs-number">0</span>; &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lab</tag>
      
      <tag>CS144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144 Lab0 : 环境搭建</title>
    <link href="/2023/01/06/CS144%20Lab0/"/>
    <url>/2023/01/06/CS144%20Lab0/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>CS144 官方镜像 : <a href="https://cs144.github.io/">https://cs144.github.io/</a></p><p><a href="https://www.cnblogs.com/kangyupl/">kangyupl</a>备份的镜像 : <a href="https://kangyupl.gitee.io/cs144.github.io/">https://kangyupl.gitee.io/cs144.github.io/</a></p><h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><hr><ul><li>Ubuntu 18.04.6 LTS x86_64 (<a href="https://stanford.edu/class/cs144/vm_howto/vm-howto-image.html">实验提供</a>)</li><li>gcc8 或 clang6 (实验机提供的gcc是7.5, 没有达到实验文档要求) </li></ul><h2 id="Writing-webget"><a href="#Writing-webget" class="headerlink" title="Writing webget"></a>Writing webget</h2><hr><p>要求使用 <a href="https://kangyupl.gitee.io/cs144.github.io/doc/lab0/class_t_c_p_socket.html"><code>TCPSocket</code></a> 和 <a href="https://kangyupl.gitee.io/cs144.github.io/doc/lab0/class_address.html"><code>Address</code></a> 来抓取网页内容。</p><p>TCP 套接字编程，实验已经使用 C++ 封装好了 <code>TCPSocket</code> 。</p><p>建立 <code>TCPSocket</code> , 并向目标主机的 <code>80</code> 号端口建立 TCP 连接。</p><p>发送 HTTP 请求报文。</p><p>HTTP 报文格式</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript">GET /somedir/page.html HTTP/<span class="hljs-number">1.1</span><span class="hljs-string">\r\n</span><br>Host: www.someschool.edu<span class="hljs-string">\r\n</span><br>Connection: close<span class="hljs-string">\r\n</span><br>User-agent: Mozilla/<span class="hljs-number">5.0</span><span class="hljs-string">\r\n</span><br>Accept-language: fr<span class="hljs-string">\r\n</span><br><span class="hljs-string">\r\n</span><br></code></pre></td></tr></table></figure><p>发送完报文，使用 <code>shutdown(SHUT_WR)</code> 表示请求发送完了。</p><p>之后使用 <code>read()</code> 读取目标主机返回的报文即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TCPSocket sock&#123;&#125;;<br>sock.<span class="hljs-built_in">connect</span>(Address&#123;host, <span class="hljs-string">&quot;http&quot;</span>&#125;);<br>sock.<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;GET &quot;</span> + path + <span class="hljs-string">&quot; HTTP/1.1\r\nHost: &quot;</span> + host + <span class="hljs-string">&quot;\r\n\r\n&quot;</span>);<br>sock.<span class="hljs-built_in">shutdown</span>(SHUT_WR);<br><span class="hljs-keyword">while</span> (!sock.<span class="hljs-built_in">eof</span>()) &#123;<br>    cout &lt;&lt; sock.<span class="hljs-built_in">read</span>();<br>&#125;<br>sock.<span class="hljs-built_in">close</span>();<br></code></pre></td></tr></table></figure><h2 id="An-in-memory-reliable-byte-stream"><a href="#An-in-memory-reliable-byte-stream" class="headerlink" title="An in-memory reliable byte stream"></a>An in-memory reliable byte stream</h2><hr><p>在内存中实现一个可靠的字节流对象，可以按照写的顺序读出数据。这个字节流是可以边写边读的。字节流读的操作会把数据从数据结构头部位置开始 <code>pop</code> 数据，写的操作会从数据结构的尾部 <code>push</code> 数据，因此我们考虑使用 <code>std::deque</code> 来实现。</p><p>为什么不使用 <code>std::queue</code> ?</p><p>读的操作分为了两步，第一步是从读取长度为 <code>len</code> 的字节流，第二步是将这长度为 <code>len</code> 的字节流从数据结构中删除。</p><p>这两个操作分为了两个函数。对于第一个函数，我们需要一个 <code>iterator</code> 来选取要取出的字节范围，而 <code>std::queue</code> 没有提供一个 <code>iterator</code> 接口。</p><p>当然，也可以使用 <code>std::list</code> 来实现这个数据结构。</p><h3 id="byte-stream-hh"><a href="#byte-stream-hh" class="headerlink" title="byte_stream.hh"></a><code>byte_stream.hh</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ByteStream</span> &#123;<br>  <span class="hljs-keyword">private</span>:<br>    std::deque&lt;<span class="hljs-type">char</span>&gt; _buffer&#123;&#125;;<br>    <span class="hljs-type">size_t</span> _capacity = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">size_t</span> _write_cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">size_t</span> _pop_cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">bool</span> _stream_end = <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">bool</span> _error = <span class="hljs-literal">false</span>; <br>    ...<br></code></pre></td></tr></table></figure><h3 id="byte-stream-cc"><a href="#byte-stream-cc" class="headerlink" title="byte_stream.cc"></a><code>byte_stream.cc</code></h3><p>构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ByteStream::<span class="hljs-built_in">ByteStream</span>(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> capacity) : _capacity&#123;capacity&#125; &#123;&#125;<br></code></pre></td></tr></table></figure><p>写的操作，因为我们的 <code>_buffer</code> 是有容量限制的，因此要判断要写入的是否超过了容量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ByteStream::write</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;data)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> res = std::<span class="hljs-built_in">min</span>(data.<span class="hljs-built_in">size</span>(), _capacity - _buffer.<span class="hljs-built_in">size</span>());<br>    _write_cnt += res;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; res; i++) &#123;<br>        _buffer.<span class="hljs-built_in">push_back</span>(data[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>读的操作，先 <code>peek_output</code> 再 <code>pop_output</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">ByteStream::peek_output</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> len)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> peek_len = std::<span class="hljs-built_in">min</span>(len, _buffer.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-keyword">return</span> std::string&#123;&#125;.<span class="hljs-built_in">assign</span>(_buffer.<span class="hljs-built_in">begin</span>(), _buffer.<span class="hljs-built_in">begin</span>() + peek_len);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ByteStream::pop_output</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> len)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> pop_len = std::<span class="hljs-built_in">min</span>(len, _buffer.<span class="hljs-built_in">size</span>());<br>    _pop_cnt += pop_len;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; pop_len; i++) &#123;<br>        _buffer.<span class="hljs-built_in">pop_front</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 输入结束，由使用者调用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ByteStream::end_input</span><span class="hljs-params">()</span> </span>&#123; _stream_end = <span class="hljs-literal">true</span>; &#125;<br><span class="hljs-comment">// `true` 表示 输入结束</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ByteStream::input_ended</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _stream_end; &#125;<br><span class="hljs-comment">// buffer 现在有多少字节</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ByteStream::buffer_size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _buffer.<span class="hljs-built_in">size</span>(); &#125;<br><span class="hljs-comment">// `true` 表示 buffer 是空的</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ByteStream::buffer_empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _buffer.<span class="hljs-built_in">empty</span>(); &#125;<br><span class="hljs-comment">// ‘true’ 表示 读 完了数据</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ByteStream::eof</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">buffer_empty</span>() &amp;&amp; <span class="hljs-built_in">input_ended</span>(); &#125;<br><span class="hljs-comment">// 写入了多少字节，写入时累积</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ByteStream::bytes_written</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _write_cnt; &#125;<br><span class="hljs-comment">// 弹出 buffer 的数据大小</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ByteStream::bytes_read</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _pop_cnt; &#125;<br><span class="hljs-comment">// 目前空余的容量大小</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ByteStream::remaining_capacity</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _capacity - _buffer.<span class="hljs-built_in">size</span>(); &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lab</tag>
      
      <tag>CS144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AtCoder Beginner Contest 282 G - Similar Permutation</title>
    <link href="/2022/12/26/AtCoder%20Beginner%20Contest%20282%20G%20-%20Similar%20Permutation/"/>
    <url>/2022/12/26/AtCoder%20Beginner%20Contest%20282%20G%20-%20Similar%20Permutation/</url>
    
    <content type="html"><![CDATA[<h2 id="套路题"><a href="#套路题" class="headerlink" title="套路题"></a>套路题</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>求有多少个 $1$ 到 $n$ 的排列满足恰有 $k$ 对在排列中相邻的数满足前小于后</p><p>$2 \leq n \leq 500, 0 \leq k \leq (n - 1)$</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><code>f[i][j][k]</code> 表示已经放置了前 <code>i</code> 个数， 放置的第<code>i</code>个数是前<code>i</code>个数中第<code>j</code>大的($ 1\leq$<code>j</code>$\leq$<code>i</code>)，已放置的前<code>i</code>个数形成的所有排列满足恰有 <code>k</code> 对在排列中相邻的数满足前小于后的排列数量。</p><p>放置第<code>i+1</code>个数时，第<code>i+1</code>个数是前<code>i+1</code>个数中第<code>j</code>大的，第<code>i</code>个数是严格小于前<code>i</code>个数中第<code>j</code>大的，会为排列增加一对相邻的数满足前小于后，第<code>i</code>个数是大于等于前<code>i</code>个数中第<code>j</code>大的，不会为排列增加一对相邻的数满足前小于后，转移方程为：<br>$$<br>f_{(i + 1) j k} = \sum_{x = 1}^{j - 1}f_{i x (k-1)} + \sum_{x=j}^{i}f_{ixk}<br>$$<br>显然，后面的和式可以通过前缀和优化的。</p><p>时间复杂度为$O(n^2k)$。</p><h2 id="G-Similar-Permutation"><a href="#G-Similar-Permutation" class="headerlink" title="G - Similar Permutation"></a>G - Similar Permutation</h2><p><a href="https://atcoder.jp/contests/abc282/tasks/abc282_g">传送门</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>求$1$到$n$的排列$A$ 和 $B$的相似度为$k$的数量。</p><p>相似度计算：$k = \sum_{i = 2}^{n}[(A_i - A_{i-1})(B_i - B_{i-1}) &gt; 0]$ ($[X] = 1, X 为真，[X] = 0, X为假$)。</p><p>$2 \leq n \leq 100, 0 \leq k \leq (n - 1)$。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>与前一道题相比，这一题只是增加了一维状态。</p><p><code>f[i][a][b][k]</code> 表示排列$A$,$B$已经放置了前 <code>i</code> 个数, 排列$A$放置的第<code>i</code>个数在排列$A$中是第<code>a</code>大的，排列$B$放置的第<code>i</code>个数在排列$B$中是第<code>b</code>大的，此时相似度为$k$的排列数量。</p><p>转移方程为：<br>$$<br>f_{(i+1)abk} = \sum_{x = 1}^{a - 1}\sum_{y = 1}^{b - 1} f_{ixy(k-1)} +<br>\sum_{x = a}^{i}\sum_{y = b}^{i} f_{ixy(k-1)} +<br>\sum_{x = 1}^{a - 1}\sum_{y = b}^{i} f_{ixyk} +<br>\sum_{x = a}^{i}\sum_{y = 1}^{b - 1} f_{ixyk}<br>$$</p><p>和式同样可以使用前缀和来优化。</p><p>时间复杂度为$O(n^4)$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> pre[<span class="hljs-number">107</span>][<span class="hljs-number">107</span>][<span class="hljs-number">107</span>], f[<span class="hljs-number">107</span>][<span class="hljs-number">107</span>][<span class="hljs-number">107</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve_problem</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m, P;<br><br>    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; P;<br><br>    <span class="hljs-keyword">auto</span> add = [&amp;](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) -&gt; <span class="hljs-type">int</span> &#123;<br>        a += b;<br>        <span class="hljs-keyword">if</span> ( a &gt;= P ) a -= P;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;;<br>    <span class="hljs-keyword">auto</span> sub = [&amp;](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) -&gt; <span class="hljs-type">int</span> &#123;<br>        a -= b;<br>        <span class="hljs-keyword">if</span> ( a &lt; <span class="hljs-number">0</span> ) a += P;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;;<br>    <span class="hljs-keyword">auto</span> sum = [&amp;](<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2) -&gt; <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(<span class="hljs-built_in">sub</span>(<span class="hljs-built_in">sub</span>(pre[n][x2][y2], pre[n][x2][y1 - <span class="hljs-number">1</span>]), pre[n][x1 - <span class="hljs-number">1</span>][y2]), pre[n][x1 - <span class="hljs-number">1</span>][y1 - <span class="hljs-number">1</span>]);<br>    &#125;;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= n; j++) <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> h = <span class="hljs-number">0</span>; h &lt;= n; h++) <br>                pre[i][j][h] = f[i][j][h] = <span class="hljs-number">0</span>;<br>    <br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= i + <span class="hljs-number">1</span>; k++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a = <span class="hljs-number">1</span>; a &lt;= i; a++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b = <span class="hljs-number">1</span>; b &lt;= i; b++) &#123;<br>                    pre[k][a][b] = <span class="hljs-built_in">add</span>(pre[k][a][b - <span class="hljs-number">1</span>], f[k][a][b]);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b = <span class="hljs-number">1</span>; b &lt;= i; b++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a = <span class="hljs-number">1</span>; a &lt;= i; a++) &#123;<br>                    pre[k][a][b] = <span class="hljs-built_in">add</span>(pre[k][a][b], pre[k][a - <span class="hljs-number">1</span>][b]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= i + <span class="hljs-number">1</span>; k++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a = <span class="hljs-number">1</span>; a &lt;= i + <span class="hljs-number">1</span>; a++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b = <span class="hljs-number">1</span>; b &lt;= i + <span class="hljs-number">1</span>; b++) &#123;<br>                    f[k][a][b] = <span class="hljs-built_in">add</span>(<br>                                    <span class="hljs-built_in">add</span>(<span class="hljs-built_in">sum</span>(k - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, a - <span class="hljs-number">1</span>, b - <span class="hljs-number">1</span>), <span class="hljs-built_in">sum</span>(k - <span class="hljs-number">1</span>, a, b, i, i)), <br>                                    <span class="hljs-built_in">add</span>(<span class="hljs-built_in">sum</span>(k, <span class="hljs-number">1</span>, b, a - <span class="hljs-number">1</span>, i), <span class="hljs-built_in">sum</span>(k, a, <span class="hljs-number">1</span>, i, b - <span class="hljs-number">1</span>))<br>                                    );<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-built_in">sum</span>(m, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, n) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AtCoder</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数位背包-梦幻岛宝珠</title>
    <link href="/2022/11/26/%E6%95%B0%E4%BD%8D%E8%83%8C%E5%8C%85-%E6%A2%A6%E5%B9%BB%E5%B2%9B%E5%AE%9D%E7%8F%A0/"/>
    <url>/2022/11/26/%E6%95%B0%E4%BD%8D%E8%83%8C%E5%8C%85-%E6%A2%A6%E5%B9%BB%E5%B2%9B%E5%AE%9D%E7%8F%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://www.luogu.com.cn/problem/P3188">P3188 [HNOI2007]梦幻岛宝珠</a></p><p>  在 $n(0\leq n \leq 100)$ 个物品中，选择重量不超过 $W(1\leq W \leq 2^{30})$ 的物品，是所选物品的总价值最大.<br>  物品的重量 $w_i$ 可以写成 $a \times 2^{b} (1\leq a \leq 10,0\leq b \leq 30)$.<br>  物品的价值 $v_i(1\leq v_i \leq 2^{30})$.</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>  通过 <strong>$w_i$ 可以写成 $a \times 2^{b} (1\leq a \leq 10,0\leq b \leq 30)$</strong> ,很容易想到通过 $b$ 分层做, 同一层之间的合并是非常简单的01背包.<br>  当前层转移到下一层是这道题的难点.<br>  定义 $f_{ij}$ 表示背包剩余的容量为 $j \times 2^i$ 时的最大价值.<br>  观察 $a \times 2^{i+1}$ 与 $a \times 2^ i$ 它们属于不同的两层, $a \times 2^{i+1}$ 可以写成 $2 \times a \times 2^i$ 这表示了 $f[i][2a] = f[i+1][a]$ 它们表示的容量相同.<br>  接下来考虑总重量 $W$ 在层与层之间转移的限制.<br>  我们从高位枚举 $W$ 时, $W$ 的第 $i$ 位为 1 时,转移到第 $i$ 层的状态为 $2 \times a + 1$ ,第 $i$ 位为 0 时, 转移到第 $i$ 层的状态为 $2 \times a + 0$.<br>  第 $i$ 层 从第 $i+1$ 层转移过来要加上 $W$ 自身的容量, $W$ 的第 $i$ 位为 1 时要加上 $2^i$.<br>  每一层在最坏情况下物品重量和不超过 1000 ,当转移过来的容量大于 1000 时就没必要保存了，因为剩余 $1000 \times 2^i$是可以把剩下的物品都取完的.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> d = (W &gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br>f[i][<span class="hljs-built_in">min</span>(<span class="hljs-number">2</span> * j + d,<span class="hljs-number">1000</span>)] = std::<span class="hljs-built_in">max</span>(f[i][<span class="hljs-built_in">min</span>(<span class="hljs-number">2</span> * j + d,<span class="hljs-number">1000</span>)],f[i+<span class="hljs-number">1</span>][j]);<br></code></pre></td></tr></table></figure><p>  因为是从高位开始枚举的，会存在许多不合法的状态，令初值全部为负无穷，f[31][0] = 0.<br>  答案为f[0][0]，背包没有剩余空间的最大值.<br>  可以通过滚动数组优化掉 $i$ .</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> i64 inf = <span class="hljs-number">1LL</span> &lt;&lt; <span class="hljs-number">60</span>;<br><span class="hljs-type">int</span> n;<br>std::vector&lt;std::pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; item[<span class="hljs-number">32</span>];<br>i64 W,f[<span class="hljs-number">2010</span>],g[<span class="hljs-number">2010</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> std::pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; <span class="hljs-title">count0</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> lev = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(;!(x &amp; <span class="hljs-number">1</span>);)&#123;<br>        lev++;<br>        x&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;lev,x&#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">30</span>;++i) item[i].<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>        <span class="hljs-type">int</span> w,v;<br>        std::cin&gt;&gt;w&gt;&gt;v;<br>       <br>        <span class="hljs-keyword">auto</span> [lev,x] = <span class="hljs-built_in">count0</span>(w);<br>        <br>        item[lev].<span class="hljs-built_in">push_back</span>(&#123;x,v&#125;);<br>        s+=x;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=s;i++) f[i] = -inf;<br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">30</span>;i&gt;=<span class="hljs-number">0</span>;--i)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;=s;j++)<br>            g[j] = f[j],f[j] = -inf;<br>        <span class="hljs-type">int</span> d = (W &gt;&gt; i) &amp; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;=s;j++)&#123;<br>            f[std::<span class="hljs-built_in">min</span>(s,<span class="hljs-number">2</span> * j + d)] = std::<span class="hljs-built_in">max</span>(f[std::<span class="hljs-built_in">min</span>(s,<span class="hljs-number">2</span> * j +d)],g[j]);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [w,v]:item[i])&#123;<br><span class="hljs-comment">// 一般背包求用了多少空间的最大值</span><br><span class="hljs-comment">// 这里表示剩余多少空间的最大值</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = w;j&lt;=s;j++)<br>                f[j-w] = std::<span class="hljs-built_in">max</span>(f[j-w],f[j]+v);<br>        &#125;<br>       <br>    &#125;<br>    std::cout&lt;&lt;f[<span class="hljs-number">0</span>]&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>数位背包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello Hexo</title>
    <link href="/2021/01/06/hello-hexo/"/>
    <url>/2021/01/06/hello-hexo/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="Sitemap"><a href="#Sitemap" class="headerlink" title="Sitemap"></a>Sitemap</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-generator-sitemap --save<br>npm install hexo-generator-baidu-sitemap --save<br></code></pre></td></tr></table></figure><h3 id="评论-Waline"><a href="#评论-Waline" class="headerlink" title="评论 Waline"></a>评论 Waline</h3><p><a href="https://waline.js.org/guide/get-started/">Waline Docs</a></p><p><a href="https://console.leancloud.app/login">LeanCloud</a> + <a href="https://vercel.com/dashboard">Vercel</a></p><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">scaffolds</span><br>  <span class="hljs-string">模板.md</span><br><span class="hljs-string">source</span><br>  <span class="hljs-string">_post</span><br>    <span class="hljs-string">文章</span><br>      <span class="hljs-string">文章.md</span><br>  <span class="hljs-string">about</span><br>  <span class="hljs-string">categories</span><br>  <span class="hljs-string">images</span><br>  <span class="hljs-string">search</span><br>  <span class="hljs-string">tags</span><br><span class="hljs-string">themes</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
